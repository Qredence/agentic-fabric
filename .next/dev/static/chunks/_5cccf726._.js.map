{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,uOAAO,EAAC,IAAA,iMAAI,EAAC;AACtB","debugId":null}},
    {"offset": {"line": 22, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/magentic-presets.ts"],"sourcesContent":["export type MagenticAgentPresetKey =\n  | \"planner\"\n  | \"web\"\n  | \"file\"\n  | \"coder\"\n  | \"terminal\"\n  | \"critic\";\n\nexport interface MagenticAgentPreset {\n  key: MagenticAgentPresetKey;\n  label: string;\n  description: string;\n  agentRole: string;\n  capabilities: string[];\n  systemPrompt: string;\n  toolIds?: string[];\n}\n\nexport const MAGENTIC_AGENT_PRESETS: MagenticAgentPreset[] = [\n  {\n    key: \"planner\",\n    label: \"Planner Agent\",\n    description: \"Creates task plans, updates task ledger, assigns agents.\",\n    agentRole: \"planner\",\n    capabilities: [\"planning\", \"fact-gathering\", \"assignment\"],\n    systemPrompt:\n      \"You are the planning specialist. Break down the task into actionable steps, keep the facts and plan ledgers updated, and assign the next best agent.\",\n    toolIds: [\"magentic-task-ledger\", \"magentic-progress-ledger\"],\n  },\n  {\n    key: \"web\",\n    label: \"Web Surfer Agent\",\n    description: \"Searches and summarizes web sources to gather external facts.\",\n    agentRole: \"web-surfer\",\n    capabilities: [\"web-search\", \"summarisation\"],\n    systemPrompt:\n      \"You are the web research specialist. Use browsing tools to gather and summarise authoritative information that helps the team.\",\n    toolIds: [\"web-browser\", \"http-client\"],\n  },\n\n  {\n    key: \"coder\",\n    label: \"Coder Agent\",\n    description: \"Writes and runs code to fulfil assigned subtasks.\",\n    agentRole: \"coder\",\n    capabilities: [\"code-generation\", \"code-execution\"],\n    systemPrompt:\n      \"You are responsible for writing and executing code to achieve the assigned goal. Produce correct, well-tested programs and explain results.\",\n    toolIds: [\"hosted-code-interpreter\"],\n  },\n\n  {\n    key: \"critic\",\n    label: \"Critic Agent\",\n    description: \"Reviews work-in-progress and ensures quality before completion.\",\n    agentRole: \"critic\",\n    capabilities: [\"review\", \"quality-assurance\"],\n    systemPrompt:\n      \"Review teammate output for accuracy, completeness, and adherence to plan. Flag issues and suggest improvements.\",\n    toolIds: [\"analysis-notes\"],\n  },\n];\n\nexport const MAGENTIC_AGENT_PRESET_MAP = MAGENTIC_AGENT_PRESETS.reduce<\n  Record<MagenticAgentPresetKey, MagenticAgentPreset>\n>((acc, preset) => {\n  acc[preset.key] = preset;\n  return acc;\n}, {} as Record<MagenticAgentPresetKey, MagenticAgentPreset>);\n"],"names":[],"mappings":";;;;;;AAkBO,MAAM,yBAAgD;IAC3D;QACE,KAAK;QACL,OAAO;QACP,aAAa;QACb,WAAW;QACX,cAAc;YAAC;YAAY;YAAkB;SAAa;QAC1D,cACE;QACF,SAAS;YAAC;YAAwB;SAA2B;IAC/D;IACA;QACE,KAAK;QACL,OAAO;QACP,aAAa;QACb,WAAW;QACX,cAAc;YAAC;YAAc;SAAgB;QAC7C,cACE;QACF,SAAS;YAAC;YAAe;SAAc;IACzC;IAEA;QACE,KAAK;QACL,OAAO;QACP,aAAa;QACb,WAAW;QACX,cAAc;YAAC;YAAmB;SAAiB;QACnD,cACE;QACF,SAAS;YAAC;SAA0B;IACtC;IAEA;QACE,KAAK;QACL,OAAO;QACP,aAAa;QACb,WAAW;QACX,cAAc;YAAC;YAAU;SAAoB;QAC7C,cACE;QACF,SAAS;YAAC;SAAiB;IAC7B;CACD;AAEM,MAAM,4BAA4B,uBAAuB,MAAM,MAEpE,CAAC,KAAK;IACN,GAAG,CAAC,OAAO,GAAG,CAAC,GAAG;IAClB,OAAO;AACT,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/executors.ts"],"sourcesContent":["import type {\n  BaseExecutor,\n  ExecutorId,\n  WorkflowContext,\n  BaseMessage,\n  Acl,\n  StatusFlag,\n} from \"./types\";\nimport type { EdgeGroup } from \"./edges\";\n\n/**\n * Base executor handler function type\n */\nexport type ExecutorHandler<TMessage extends BaseMessage = BaseMessage> = (\n  context: WorkflowContext<TMessage>\n) => Promise<TMessage[] | void> | TMessage[] | void;\n\n/**\n * Core Executor - base class for all workflow executors\n */\nexport interface Executor<TMessage extends BaseMessage = BaseMessage>\n  extends BaseExecutor {\n  type: \"executor\";\n  handler?: ExecutorHandler<TMessage>;\n}\n\n/**\n * Function Executor - wraps user-defined functions (sync/async) to use as workflow nodes\n */\nexport interface FunctionExecutor<TMessage extends BaseMessage = BaseMessage>\n  extends BaseExecutor {\n  type: \"function-executor\";\n  functionName: string;\n  functionCode?: string; // For code-based functions\n  functionId?: string; // For registered functions\n  parameters?: Record<string, unknown>;\n  handler: ExecutorHandler<TMessage>;\n}\n\n/**\n * Workflow Executor - wraps a workflow as a single executor, enabling hierarchical nested workflows\n */\nexport interface WorkflowExecutor extends BaseExecutor {\n  type: \"workflow-executor\";\n  workflowId: string;\n  workflowDefinition?: WorkflowDefinition;\n  inputMapping?: Record<string, string>;\n  outputMapping?: Record<string, string>;\n}\n\n/**\n * Workflow definition structure\n */\nexport interface WorkflowDefinition {\n  id: string;\n  name?: string;\n  executors: BaseExecutor[];\n  edges: EdgeDefinition[];\n  metadata?: Record<string, unknown>;\n  edgeGroups?: EdgeGroup[];\n  version?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  acl?: Acl;\n  status?: StatusFlag;\n}\n\n/**\n * Edge definition in workflow\n */\nexport interface EdgeDefinition {\n  id: string;\n  source: ExecutorId;\n  target: ExecutorId;\n  condition?: EdgeConditionDefinition;\n}\n\n/**\n * Edge condition definition\n */\nexport interface EdgeConditionDefinition {\n  type: \"predicate\" | \"case\";\n  expression?: string;\n  caseValue?: string;\n}\n\n/**\n * Agent Executor - built-in executor that wraps an agent for handling messages in workflows\n */\nexport interface AgentExecutor extends BaseExecutor {\n  type: \"agent-executor\";\n  agentId: string;\n  agentType?: \"chat\" | \"workflow\" | \"magentic\";\n  systemPrompt?: string;\n  tools?: ToolReference[];\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  toolMode?: \"auto\" | \"required\" | \"none\";\n}\n\n/**\n * Tool reference in executor\n */\nexport interface ToolReference {\n  toolId: string;\n  enabled?: boolean;\n  parameters?: Record<string, unknown>;\n}\n\n/**\n * Request Info Executor - gateway for external information requests\n */\nexport interface RequestInfoExecutor extends BaseExecutor {\n  type: \"request-info-executor\";\n  requestType: string;\n  timeout?: number;\n  retryPolicy?: RetryPolicy;\n  responseHandler?: string;\n}\n\n/**\n * Retry policy configuration\n */\nexport interface RetryPolicy {\n  maxRetries: number;\n  backoffMs?: number;\n  exponentialBackoff?: boolean;\n}\n\n/**\n * Magentic Agent Executor - Magentic agent executor for participation in multi-agent workflows\n */\nexport interface MagenticAgentExecutor extends BaseExecutor {\n  type: \"magentic-agent-executor\";\n  agentRole: string;\n  capabilities?: string[];\n  systemPrompt?: string;\n  tools?: ToolReference[];\n}\n\n/**\n * Magentic Orchestrator Executor - handles orchestration logic for Magentic One workflows\n */\nexport interface MagenticOrchestratorExecutor extends BaseExecutor {\n  type: \"magentic-orchestrator-executor\";\n  planningStrategy?: \"sequential\" | \"parallel\" | \"adaptive\";\n  progressTracking?: boolean;\n  humanInTheLoop?: boolean;\n}\n\n/**\n * Union type of all executor types\n */\nexport type WorkflowExecutorType =\n  | Executor\n  | FunctionExecutor\n  | WorkflowExecutor\n  | AgentExecutor\n  | RequestInfoExecutor\n  | MagenticAgentExecutor\n  | MagenticOrchestratorExecutor;\n\n/**\n * Executor type discriminator\n */\nexport type ExecutorType =\n  | \"executor\"\n  | \"function-executor\"\n  | \"workflow-executor\"\n  | \"agent-executor\"\n  | \"request-info-executor\"\n  | \"magentic-agent-executor\"\n  | \"magentic-orchestrator-executor\";\n\n/**\n * Type guard helpers\n */\nexport function isFunctionExecutor(\n  executor: BaseExecutor\n): executor is FunctionExecutor {\n  return executor.type === \"function-executor\";\n}\n\nexport function isWorkflowExecutor(\n  executor: BaseExecutor\n): executor is WorkflowExecutor {\n  return executor.type === \"workflow-executor\";\n}\n\nexport function isAgentExecutor(\n  executor: BaseExecutor\n): executor is AgentExecutor {\n  return executor.type === \"agent-executor\";\n}\n\nexport function isRequestInfoExecutor(\n  executor: BaseExecutor\n): executor is RequestInfoExecutor {\n  return executor.type === \"request-info-executor\";\n}\n\nexport function isMagenticAgentExecutor(\n  executor: BaseExecutor\n): executor is MagenticAgentExecutor {\n  return executor.type === \"magentic-agent-executor\";\n}\n\nexport function isMagenticOrchestratorExecutor(\n  executor: BaseExecutor\n): executor is MagenticOrchestratorExecutor {\n  return executor.type === \"magentic-orchestrator-executor\";\n}\n\n/**\n * Get executor type label for UI\n */\nexport function getExecutorTypeLabel(type: ExecutorType): string {\n  const labels: Record<ExecutorType, string> = {\n    executor: \"Executor\",\n    \"function-executor\": \"Function\",\n    \"workflow-executor\": \"Nested Workflow\",\n    \"agent-executor\": \"Agent\",\n    \"request-info-executor\": \"Request Info\",\n    \"magentic-agent-executor\": \"Magentic Agent\",\n    \"magentic-orchestrator-executor\": \"Magentic Orchestrator\",\n  };\n  return labels[type] || type;\n}\n\n/**\n * Get executor type description for UI\n */\nexport function getExecutorTypeDescription(type: ExecutorType): string {\n  const descriptions: Record<ExecutorType, string> = {\n    executor: \"Base executor for processing messages\",\n    \"function-executor\": \"Execute a function as a workflow node\",\n    \"workflow-executor\": \"Nest another workflow as an executor\",\n    \"agent-executor\": \"Use an AI agent to process messages\",\n    \"request-info-executor\": \"Gateway for external information requests\",\n    \"magentic-agent-executor\": \"Magentic agent for multi-agent workflows\",\n    \"magentic-orchestrator-executor\": \"Orchestrator for Magentic One workflows\",\n  };\n  return descriptions[type] || \"\";\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAkLO,SAAS,mBACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAEO,SAAS,mBACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAEO,SAAS,gBACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAEO,SAAS,sBACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAEO,SAAS,wBACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAEO,SAAS,+BACd,QAAsB;IAEtB,OAAO,SAAS,IAAI,KAAK;AAC3B;AAKO,SAAS,qBAAqB,IAAkB;IACrD,MAAM,SAAuC;QAC3C,UAAU;QACV,qBAAqB;QACrB,qBAAqB;QACrB,kBAAkB;QAClB,yBAAyB;QACzB,2BAA2B;QAC3B,kCAAkC;IACpC;IACA,OAAO,MAAM,CAAC,KAAK,IAAI;AACzB;AAKO,SAAS,2BAA2B,IAAkB;IAC3D,MAAM,eAA6C;QACjD,UAAU;QACV,qBAAqB;QACrB,qBAAqB;QACrB,kBAAkB;QAClB,yBAAyB;QACzB,2BAA2B;QAC3B,kCAAkC;IACpC;IACA,OAAO,YAAY,CAAC,KAAK,IAAI;AAC/B","debugId":null}},
    {"offset": {"line": 171, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/edges.ts"],"sourcesContent":["import type { BaseEdge, EdgeId, ExecutorId, EdgeGroupType } from \"./types\";\n\n/**\n * Single Edge Group - convenience wrapper for a one-to-one edge connection\n */\nexport interface SingleEdgeGroup {\n  id: string;\n  type: \"single\";\n  edge: BaseEdge;\n}\n\n/**\n * Fan-In Edge Group - converging edges where multiple sources feed into a single downstream executor\n */\nexport interface FanInEdgeGroup {\n  id: string;\n  type: \"fan-in\";\n  sources: ExecutorId[];\n  target: ExecutorId;\n  edges: BaseEdge[];\n  aggregationStrategy?: \"merge\" | \"first\" | \"all\" | \"custom\";\n  customAggregator?: string;\n}\n\n/**\n * Fan-Out Edge Group - broadcast-style routing where one source sends to multiple targets\n */\nexport interface FanOutEdgeGroup {\n  id: string;\n  type: \"fan-out\";\n  source: ExecutorId;\n  targets: ExecutorId[];\n  edges: BaseEdge[];\n  broadcastMode?: \"parallel\" | \"sequential\" | \"condition-based\";\n}\n\n/**\n * Switch Case Edge Group - switch/case control flow routing for conditional message dispatch\n */\nexport interface SwitchCaseEdgeGroup {\n  id: string;\n  type: \"switch-case\";\n  source: ExecutorId;\n  cases: Case[];\n  default?: DefaultCase;\n  switchExpression: string; // Expression to evaluate for switching\n}\n\n/**\n * Case - runtime wrapper for switch-case predicates with routing targets\n */\nexport interface Case {\n  id: string;\n  value: string | number | boolean;\n  target: ExecutorId;\n  condition?: string; // Optional additional condition\n  edge: BaseEdge;\n}\n\n/**\n * Default - default branch for switch-case groups when no cases match\n */\nexport interface DefaultCase {\n  target: ExecutorId;\n  edge: BaseEdge;\n}\n\n/**\n * Union type of all edge groups\n */\nexport type EdgeGroup = SingleEdgeGroup | FanInEdgeGroup | FanOutEdgeGroup | SwitchCaseEdgeGroup;\n\n/**\n * Edge configuration with metadata\n */\nexport interface EdgeConfiguration {\n  id: EdgeId;\n  source: ExecutorId;\n  target: ExecutorId;\n  condition?: EdgeCondition;\n  label?: string;\n  style?: EdgeStyle;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Edge condition for conditional routing\n */\nexport interface EdgeCondition {\n  type: \"predicate\" | \"case\" | \"always\";\n  expression?: string; // For predicate-based conditions (e.g., \"message.type === 'error'\")\n  caseValue?: string; // For switch-case conditions\n  operator?: \"equals\" | \"not-equals\" | \"contains\" | \"greater-than\" | \"less-than\";\n  value?: unknown;\n}\n\n/**\n * Edge visual style\n */\nexport interface EdgeStyle {\n  stroke?: string;\n  strokeWidth?: number;\n  strokeDasharray?: string;\n  animated?: boolean;\n  labelStyle?: {\n    fill?: string;\n    fontSize?: number;\n    fontWeight?: string;\n  };\n}\n\n/**\n * Type guard helpers\n */\nexport function isSingleEdgeGroup(group: EdgeGroup): group is SingleEdgeGroup {\n  return group.type === \"single\";\n}\n\nexport function isFanInEdgeGroup(group: EdgeGroup): group is FanInEdgeGroup {\n  return group.type === \"fan-in\";\n}\n\nexport function isFanOutEdgeGroup(group: EdgeGroup): group is FanOutEdgeGroup {\n  return group.type === \"fan-out\";\n}\n\nexport function isSwitchCaseEdgeGroup(\n  group: EdgeGroup\n): group is SwitchCaseEdgeGroup {\n  return group.type === \"switch-case\";\n}\n\n/**\n * Get edge group type label\n */\nexport function getEdgeGroupTypeLabel(type: EdgeGroupType): string {\n  const labels: Record<EdgeGroupType, string> = {\n    single: \"Single Edge\",\n    \"fan-in\": \"Fan-In (Multiple Sources)\",\n    \"fan-out\": \"Fan-Out (Multiple Targets)\",\n    \"switch-case\": \"Switch/Case Routing\",\n  };\n  return labels[type] || type;\n}\n\n/**\n * Get edge group type description\n */\nexport function getEdgeGroupTypeDescription(type: EdgeGroupType): string {\n  const descriptions: Record<EdgeGroupType, string> = {\n    single: \"One-to-one connection between executors\",\n    \"fan-in\": \"Multiple sources converge into one target\",\n    \"fan-out\": \"One source broadcasts to multiple targets\",\n    \"switch-case\": \"Conditional routing based on expression value\",\n  };\n  return descriptions[type] || \"\";\n}\n\n/**\n * Create a single edge group from a base edge\n */\nexport function createSingleEdgeGroup(edge: BaseEdge): SingleEdgeGroup {\n  return {\n    id: `edge-group-${edge.id}`,\n    type: \"single\",\n    edge,\n  };\n}\n\n/**\n * Create a fan-in edge group\n */\nexport function createFanInEdgeGroup(\n  sources: ExecutorId[],\n  target: ExecutorId,\n  edges: BaseEdge[],\n  aggregationStrategy: \"merge\" | \"first\" | \"all\" = \"merge\"\n): FanInEdgeGroup {\n  return {\n    id: `fan-in-${Date.now()}`,\n    type: \"fan-in\",\n    sources,\n    target,\n    edges,\n    aggregationStrategy,\n  };\n}\n\n/**\n * Create a fan-out edge group\n */\nexport function createFanOutEdgeGroup(\n  source: ExecutorId,\n  targets: ExecutorId[],\n  edges: BaseEdge[],\n  broadcastMode: \"parallel\" | \"sequential\" = \"parallel\"\n): FanOutEdgeGroup {\n  return {\n    id: `fan-out-${Date.now()}`,\n    type: \"fan-out\",\n    source,\n    targets,\n    edges,\n    broadcastMode,\n  };\n}\n\n/**\n * Create a switch-case edge group\n */\nexport function createSwitchCaseEdgeGroup(\n  source: ExecutorId,\n  switchExpression: string,\n  cases: Case[],\n  defaultCase?: DefaultCase\n): SwitchCaseEdgeGroup {\n  return {\n    id: `switch-case-${Date.now()}`,\n    type: \"switch-case\",\n    source,\n    switchExpression,\n    cases,\n    default: defaultCase,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAkHO,SAAS,kBAAkB,KAAgB;IAChD,OAAO,MAAM,IAAI,KAAK;AACxB;AAEO,SAAS,iBAAiB,KAAgB;IAC/C,OAAO,MAAM,IAAI,KAAK;AACxB;AAEO,SAAS,kBAAkB,KAAgB;IAChD,OAAO,MAAM,IAAI,KAAK;AACxB;AAEO,SAAS,sBACd,KAAgB;IAEhB,OAAO,MAAM,IAAI,KAAK;AACxB;AAKO,SAAS,sBAAsB,IAAmB;IACvD,MAAM,SAAwC;QAC5C,QAAQ;QACR,UAAU;QACV,WAAW;QACX,eAAe;IACjB;IACA,OAAO,MAAM,CAAC,KAAK,IAAI;AACzB;AAKO,SAAS,4BAA4B,IAAmB;IAC7D,MAAM,eAA8C;QAClD,QAAQ;QACR,UAAU;QACV,WAAW;QACX,eAAe;IACjB;IACA,OAAO,YAAY,CAAC,KAAK,IAAI;AAC/B;AAKO,SAAS,sBAAsB,IAAc;IAClD,OAAO;QACL,IAAI,CAAC,WAAW,EAAE,KAAK,EAAE,EAAE;QAC3B,MAAM;QACN;IACF;AACF;AAKO,SAAS,qBACd,OAAqB,EACrB,MAAkB,EAClB,KAAiB,EACjB,sBAAiD,OAAO;IAExD,OAAO;QACL,IAAI,CAAC,OAAO,EAAE,KAAK,GAAG,IAAI;QAC1B,MAAM;QACN;QACA;QACA;QACA;IACF;AACF;AAKO,SAAS,sBACd,MAAkB,EAClB,OAAqB,EACrB,KAAiB,EACjB,gBAA2C,UAAU;IAErD,OAAO;QACL,IAAI,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI;QAC3B,MAAM;QACN;QACA;QACA;QACA;IACF;AACF;AAKO,SAAS,0BACd,MAAkB,EAClB,gBAAwB,EACxB,KAAa,EACb,WAAyB;IAEzB,OAAO;QACL,IAAI,CAAC,YAAY,EAAE,KAAK,GAAG,IAAI;QAC/B,MAAM;QACN;QACA;QACA;QACA,SAAS;IACX;AACF","debugId":null}},
    {"offset": {"line": 267, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/export/serializers.ts"],"sourcesContent":["import * as yaml from \"js-yaml\";\nimport type { Workflow } from \"../workflow\";\nimport type { BaseExecutor } from \"../types\";\nimport type { BaseEdge } from \"../types\";\nimport type { EdgeGroup } from \"../edges\";\n\n/**\n * Serialized workflow format for export\n */\nexport interface SerializedWorkflow {\n  id: string;\n  name?: string;\n  version?: string;\n  description?: string;\n  executors: SerializedExecutor[];\n  edges: SerializedEdge[];\n  edgeGroups?: SerializedEdgeGroup[];\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Serialized executor\n */\nexport interface SerializedExecutor {\n  id: string;\n  type: string;\n  label?: string;\n  description?: string;\n  [key: string]: unknown;\n}\n\n/**\n * Serialized edge\n */\nexport interface SerializedEdge {\n  id: string;\n  source: string;\n  target: string;\n  condition?: {\n    type: string;\n    expression?: string;\n    caseValue?: string;\n  };\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Serialized edge group\n */\nexport interface SerializedEdgeGroup {\n  id: string;\n  type: string;\n  [key: string]: unknown;\n}\n\n/**\n * Serialize workflow to JSON\n */\nexport function serializeToJSON(workflow: Workflow, pretty: boolean = true): string {\n  const serialized = workflowToSerialized(workflow);\n  return pretty\n    ? JSON.stringify(serialized, null, 2)\n    : JSON.stringify(serialized);\n}\n\n/**\n * Serialize workflow to YAML\n */\nexport function serializeToYAML(workflow: Workflow): string {\n  const serialized = workflowToSerialized(workflow);\n  return yaml.dump(serialized, {\n    indent: 2,\n    lineWidth: -1,\n    noRefs: true,\n  });\n}\n\n/**\n * Deserialize workflow from JSON\n */\nexport function deserializeFromJSON(json: string): Workflow {\n  const parsed = JSON.parse(json) as SerializedWorkflow;\n  return serializedToWorkflow(parsed);\n}\n\n/**\n * Deserialize workflow from YAML\n */\nexport function deserializeFromYAML(yamlString: string): Workflow {\n  const parsed = yaml.load(yamlString) as SerializedWorkflow;\n  return serializedToWorkflow(parsed);\n}\n\n/**\n * Convert workflow to serialized format\n */\nfunction workflowToSerialized(workflow: Workflow): SerializedWorkflow {\n  return {\n    id: workflow.id,\n    name: workflow.name,\n    version: workflow.version,\n    description: workflow.description,\n    executors: workflow.executors.map(executorToSerialized),\n    edges: workflow.edges.map(edgeToSerialized),\n    edgeGroups: workflow.edgeGroups?.map(edgeGroupToSerialized),\n    metadata: workflow.metadata as Record<string, unknown> | undefined,\n  };\n}\n\n/**\n * Convert serialized format to workflow\n */\nfunction serializedToWorkflow(serialized: SerializedWorkflow): Workflow {\n  return {\n    id: serialized.id,\n    name: serialized.name,\n    version: serialized.version,\n    description: serialized.description,\n    executors: serialized.executors.map(serializedToExecutor),\n    edges: serialized.edges.map(serializedToEdge),\n    edgeGroups: serialized.edgeGroups?.map(serializedToEdgeGroup),\n    metadata: serialized.metadata,\n  };\n}\n\n/**\n * Convert executor to serialized format\n */\nfunction executorToSerialized(executor: BaseExecutor): SerializedExecutor {\n  const serialized: SerializedExecutor = {\n    id: executor.id,\n    type: executor.type,\n  };\n\n  if (executor.label) {\n    serialized.label = executor.label;\n  }\n  if (executor.description) {\n    serialized.description = executor.description;\n  }\n\n  // Copy all other properties\n  Object.keys(executor).forEach((key) => {\n    if (![\"id\", \"type\", \"label\", \"description\"].includes(key)) {\n      serialized[key] = (executor as unknown as Record<string, unknown>)[key];\n    }\n  });\n\n  return serialized;\n}\n\n/**\n * Convert serialized executor to executor\n */\nfunction serializedToExecutor(serialized: SerializedExecutor): BaseExecutor {\n  const { id, type, ...rest } = serialized;\n  const executor = {\n    id,\n    type,\n    ...rest,\n  } as BaseExecutor;\n\n  if (serialized.label) {\n    executor.label = serialized.label;\n  }\n  if (serialized.description) {\n    executor.description = serialized.description;\n  }\n\n  return executor;\n}\n\n/**\n * Convert edge to serialized format\n */\nfunction edgeToSerialized(edge: BaseEdge): SerializedEdge {\n  const serialized: SerializedEdge = {\n    id: edge.id,\n    source: edge.source,\n    target: edge.target,\n  };\n\n  if (edge.condition) {\n    if (edge.condition.type === \"predicate\") {\n      serialized.condition = {\n        type: edge.condition.type,\n        expression: edge.condition.expression,\n      };\n    } else if (edge.condition.type === \"case\") {\n      serialized.condition = {\n        type: edge.condition.type,\n        caseValue: edge.condition.caseValue,\n      };\n    }\n  }\n\n  if (edge.metadata) {\n    serialized.metadata = edge.metadata;\n  }\n\n  return serialized;\n}\n\n/**\n * Convert serialized edge to edge\n */\nfunction serializedToEdge(serialized: SerializedEdge): BaseEdge {\n  const edge: BaseEdge = {\n    id: serialized.id,\n    source: serialized.source,\n    target: serialized.target,\n  };\n\n  if (serialized.condition && (serialized.condition.type === \"predicate\" || serialized.condition.type === \"case\")) {\n    if (serialized.condition.type === \"predicate\") {\n      edge.condition = {\n        type: \"predicate\" as const,\n        expression: serialized.condition.expression,\n      };\n    } else {\n      edge.condition = {\n        type: \"case\" as const,\n        caseValue: serialized.condition.caseValue,\n      };\n    }\n  }\n\n  if (serialized.metadata) {\n    edge.metadata = serialized.metadata;\n  }\n\n  return edge;\n}\n\n/**\n * Convert edge group to serialized format\n */\nfunction edgeGroupToSerialized(group: EdgeGroup): SerializedEdgeGroup {\n  const { id, type, ...rest } = group;\n  const serialized: SerializedEdgeGroup = {\n    id,\n    type,\n    ...rest,\n  };\n  return serialized;\n}\n\n/**\n * Convert serialized edge group to edge group\n */\nfunction serializedToEdgeGroup(serialized: SerializedEdgeGroup): EdgeGroup {\n  // This is a simplified conversion - actual implementation would need\n  // to handle each edge group type specifically\n  return serialized as unknown as EdgeGroup;\n}\n\n/**\n * Download workflow as file\n */\nexport function downloadWorkflow(\n  workflow: Workflow,\n  format: \"json\" | \"yaml\",\n  filename?: string\n): void {\n  const content =\n    format === \"json\"\n      ? serializeToJSON(workflow, true)\n      : serializeToYAML(workflow);\n\n  const blob = new Blob([content], {\n    type: format === \"json\" ? \"application/json\" : \"text/yaml\",\n  });\n\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement(\"a\");\n  link.href = url;\n  link.download = filename || `${workflow.id || \"workflow\"}.${format}`;\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n  URL.revokeObjectURL(url);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/workflow.ts"],"sourcesContent":["import type {\n  BaseExecutor,\n  BaseEdge,\n  ExecutorId,\n  EdgeId,\n  WorkflowContext,\n  BaseMessage,\n  SharedState,\n} from \"./types\";\nimport type {\n  WorkflowDefinition,\n  EdgeDefinition,\n  WorkflowExecutorType,\n} from \"./executors\";\nimport type { EdgeGroup } from \"./edges\";\nimport type { WorkflowEvent } from \"./events\";\n\n/**\n * Workflow - graph-based execution engine that orchestrates connected executors\n */\nexport interface Workflow {\n  id: string;\n  name?: string;\n  version?: string;\n  description?: string;\n  executors: BaseExecutor[];\n  edges: BaseEdge[];\n  edgeGroups?: EdgeGroup[];\n  metadata?: WorkflowMetadata;\n  state?: WorkflowState;\n}\n\n/**\n * Workflow metadata\n */\nexport interface WorkflowMetadata {\n  author?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  tags?: string[];\n  custom?: Record<string, unknown>;\n}\n\n/**\n * Workflow state during execution\n */\nexport interface WorkflowState {\n  runId: string;\n  status: WorkflowStatus;\n  sharedState: SharedState;\n  checkpoints?: WorkflowCheckpoint[];\n  events: WorkflowEvent[];\n  startedAt?: string;\n  completedAt?: string;\n  failedAt?: string;\n  error?: WorkflowError;\n}\n\n/**\n * Workflow status\n */\nexport type WorkflowStatus =\n  | \"pending\"\n  | \"running\"\n  | \"completed\"\n  | \"failed\"\n  | \"cancelled\";\n\n/**\n * Workflow error\n */\nexport interface WorkflowError {\n  code: string;\n  message: string;\n  details?: unknown;\n  executorId?: ExecutorId;\n  timestamp: string;\n}\n\n/**\n * Workflow checkpoint - complete checkpoint of workflow state\n */\nexport interface WorkflowCheckpoint {\n  id: string;\n  timestamp: string;\n  state: WorkflowState;\n  executorStates?: Record<ExecutorId, ExecutorState>;\n}\n\n/**\n * Executor state\n */\nexport interface ExecutorState {\n  executorId: ExecutorId;\n  status: \"pending\" | \"running\" | \"completed\" | \"failed\";\n  messages?: BaseMessage[];\n  error?: WorkflowError;\n  startedAt?: string;\n  completedAt?: string;\n}\n\n/**\n * Workflow Builder - primary builder for constructing custom workflows\n */\nexport interface WorkflowBuilder {\n  workflow: Workflow;\n\n  /**\n   * Add an executor to the workflow\n   */\n  addExecutor(executor: BaseExecutor): WorkflowBuilder;\n\n  /**\n   * Add multiple executors\n   */\n  addExecutors(executors: BaseExecutor[]): WorkflowBuilder;\n\n  /**\n   * Add an edge between executors\n   */\n  addEdge(\n    source: ExecutorId,\n    target: ExecutorId,\n    condition?: EdgeCondition\n  ): WorkflowBuilder;\n\n  /**\n   * Add multiple edges\n   */\n  addEdges(edges: BaseEdge[]): WorkflowBuilder;\n\n  /**\n   * Add an edge group\n   */\n  addEdgeGroup(group: EdgeGroup): WorkflowBuilder;\n\n  /**\n   * Set workflow metadata\n   */\n  setMetadata(metadata: WorkflowMetadata): WorkflowBuilder;\n\n  /**\n   * Build the workflow\n   */\n  build(): Workflow;\n}\n\n/**\n * Edge condition for builder\n */\nexport interface EdgeCondition {\n  type: \"predicate\" | \"case\" | \"always\";\n  expression?: string;\n  caseValue?: string;\n}\n\n/**\n * Workflow Runner - runs workflows in Pregel supersteps\n */\nexport interface WorkflowRunner {\n  run(workflow: Workflow, input?: unknown[]): Promise<WorkflowRunResult>;\n  stream?(\n    workflow: Workflow,\n    input?: unknown[]\n  ): AsyncIterable<WorkflowRunResult>;\n}\n\n/**\n * Workflow Run Result - container for events from workflow execution\n */\nexport interface WorkflowRunResult {\n  workflowId: string;\n  runId: string;\n  status: WorkflowStatus;\n  events: WorkflowEvent[];\n  output?: unknown;\n  error?: WorkflowError;\n  duration?: number;\n}\n\n/**\n * Runner Context - protocol for execution context\n */\nexport interface RunnerContext {\n  sendMessage: (target: ExecutorId, message: BaseMessage) => void;\n  yieldOutput: (output: unknown) => void;\n  emitEvent: (event: WorkflowEvent) => void;\n  checkpoint?: () => Promise<void>;\n}\n\n/**\n * In-Process Runner Context - in-process execution context with optional checkpointing\n */\nexport interface InProcRunnerContext extends RunnerContext {\n  workflowId: string;\n  runId: string;\n  sharedState: SharedState;\n  checkpoints: WorkflowCheckpoint[];\n  enableCheckpointing: boolean;\n}\n\n/**\n * Create a new workflow builder\n */\nexport function createWorkflowBuilder(id: string, name?: string): WorkflowBuilder {\n  const workflow: Workflow = {\n    id,\n    name,\n    executors: [],\n    edges: [],\n    edgeGroups: [],\n    metadata: {},\n  };\n\n  return {\n    workflow,\n\n    addExecutor(executor: BaseExecutor) {\n      this.workflow.executors.push(executor);\n      return this;\n    },\n\n    addExecutors(executors: BaseExecutor[]) {\n      this.workflow.executors.push(...executors);\n      return this;\n    },\n\n    addEdge(source: ExecutorId, target: ExecutorId, condition?: EdgeCondition) {\n      const edge: BaseEdge = {\n        id: `edge-${this.workflow.edges.length + 1}`,\n        source,\n        target,\n        condition: condition\n          ? {\n              type: condition.type,\n              expression: condition.expression,\n              caseValue: condition.caseValue,\n            }\n          : undefined,\n      };\n      this.workflow.edges.push(edge);\n      return this;\n    },\n\n    addEdges(edges: BaseEdge[]) {\n      this.workflow.edges.push(...edges);\n      return this;\n    },\n\n    addEdgeGroup(group: EdgeGroup) {\n      if (!this.workflow.edgeGroups) {\n        this.workflow.edgeGroups = [];\n      }\n      this.workflow.edgeGroups.push(group);\n      return this;\n    },\n\n    setMetadata(metadata: WorkflowMetadata) {\n      this.workflow.metadata = { ...this.workflow.metadata, ...metadata };\n      return this;\n    },\n\n    build() {\n      return { ...this.workflow };\n    },\n  };\n}\n\n/**\n * Validate workflow structure\n */\nexport interface WorkflowValidationResult {\n  valid: boolean;\n  errors: WorkflowValidationError[];\n  warnings: WorkflowValidationWarning[];\n}\n\n/**\n * Workflow validation error\n */\nexport interface WorkflowValidationError {\n  code: string;\n  message: string;\n  executorId?: ExecutorId;\n  edgeId?: EdgeId;\n}\n\n/**\n * Workflow validation warning\n */\nexport interface WorkflowValidationWarning {\n  code: string;\n  message: string;\n  executorId?: ExecutorId;\n  edgeId?: EdgeId;\n}\n\n/**\n * Validate workflow\n */\nexport function validateWorkflow(\n  workflow: Workflow\n): WorkflowValidationResult {\n  const errors: WorkflowValidationError[] = [];\n  const warnings: WorkflowValidationWarning[] = [];\n\n  // Check for duplicate executor IDs\n  const executorIds = new Set<ExecutorId>();\n  for (const executor of workflow.executors) {\n    if (executorIds.has(executor.id)) {\n      errors.push({\n        code: \"duplicate-executor-id\",\n        message: `Duplicate executor ID: ${executor.id}`,\n        executorId: executor.id,\n      });\n    }\n    executorIds.add(executor.id);\n  }\n\n  // Check for duplicate edge IDs\n  const edgeIds = new Set<EdgeId>();\n  for (const edge of workflow.edges) {\n    if (edgeIds.has(edge.id)) {\n      errors.push({\n        code: \"duplicate-edge-id\",\n        message: `Duplicate edge ID: ${edge.id}`,\n        edgeId: edge.id,\n      });\n    }\n    edgeIds.add(edge.id);\n\n    // Check that source and target executors exist\n    if (!executorIds.has(edge.source)) {\n      errors.push({\n        code: \"invalid-edge-source\",\n        message: `Edge source executor not found: ${edge.source}`,\n        edgeId: edge.id,\n        executorId: edge.source,\n      });\n    }\n    if (!executorIds.has(edge.target)) {\n      errors.push({\n        code: \"invalid-edge-target\",\n        message: `Edge target executor not found: ${edge.target}`,\n        edgeId: edge.id,\n        executorId: edge.target,\n      });\n    }\n  }\n\n  // Check for orphaned executors (no incoming or outgoing edges)\n  for (const executor of workflow.executors) {\n    const hasIncoming = workflow.edges.some((e) => e.target === executor.id);\n    const hasOutgoing = workflow.edges.some((e) => e.source === executor.id);\n    if (!hasIncoming && !hasOutgoing) {\n      warnings.push({\n        code: \"orphaned-executor\",\n        message: `Executor has no connections: ${executor.id}`,\n        executorId: executor.id,\n      });\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n\n/**\n * Convert workflow definition to workflow\n */\nexport function workflowDefinitionToWorkflow(\n  definition: WorkflowDefinition\n): Workflow {\n  return {\n    id: definition.id,\n    name: definition.name,\n    executors: definition.executors,\n    edges: definition.edges.map((edge) => ({\n      id: edge.id,\n      source: edge.source,\n      target: edge.target,\n      condition: edge.condition\n        ? {\n            type: edge.condition.type,\n            expression: edge.condition.expression,\n            caseValue: edge.condition.caseValue,\n          }\n        : undefined,\n    })),\n    metadata: definition.metadata,\n  };\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 618, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/export/validator.ts"],"sourcesContent":["import type { Workflow } from \"../workflow\";\nimport type {\n  WorkflowValidationResult,\n  WorkflowValidationError,\n  WorkflowValidationWarning,\n} from \"../workflow\";\nimport { validateWorkflow as validateWorkflowStructure } from \"../workflow\";\nimport type { BaseExecutor } from \"../types\";\nimport type { ExecutorType } from \"../executors\";\n\n/**\n * Extended validation result with additional checks\n */\nexport interface ExtendedValidationResult extends WorkflowValidationResult {\n  typeErrors: TypeValidationError[];\n  connectivityWarnings: ConnectivityWarning[];\n}\n\n/**\n * Type validation error\n */\nexport interface TypeValidationError {\n  code: string;\n  message: string;\n  executorId?: string;\n  edgeId?: string;\n  expectedType?: string;\n  actualType?: string;\n}\n\n/**\n * Connectivity warning\n */\nexport interface ConnectivityWarning {\n  code: string;\n  message: string;\n  executorId?: string;\n  connectedExecutors?: string[];\n}\n\n/**\n * Validate workflow with extended checks\n */\nexport function validateWorkflowExtended(\n  workflow: Workflow\n): ExtendedValidationResult {\n  const baseValidation = validateWorkflowStructure(workflow);\n  const typeErrors: TypeValidationError[] = [];\n  const connectivityWarnings: ConnectivityWarning[] = [];\n\n  // Validate executor types\n  for (const executor of workflow.executors) {\n    const typeError = validateExecutorType(executor);\n    if (typeError) {\n      typeErrors.push(typeError);\n    }\n  }\n\n  // Validate edge type compatibility\n  for (const edge of workflow.edges) {\n    const sourceExecutor = workflow.executors.find((e) => e.id === edge.source);\n    const targetExecutor = workflow.executors.find((e) => e.id === edge.target);\n\n    if (sourceExecutor && targetExecutor) {\n      const compatibilityError = validateEdgeCompatibility(\n        sourceExecutor,\n        targetExecutor,\n        edge\n      );\n      if (compatibilityError) {\n        typeErrors.push(compatibilityError);\n      }\n    }\n  }\n\n  // Check connectivity\n  for (const executor of workflow.executors) {\n    const connected = getConnectedExecutors(workflow, executor.id);\n    if (connected.incoming.length === 0 && connected.outgoing.length === 0) {\n      connectivityWarnings.push({\n        code: \"isolated-executor\",\n        message: `Executor ${executor.id} is isolated (no connections)`,\n        executorId: executor.id,\n      });\n    } else if (connected.incoming.length === 0) {\n      connectivityWarnings.push({\n        code: \"no-incoming-edges\",\n        message: `Executor ${executor.id} has no incoming edges`,\n        executorId: executor.id,\n        connectedExecutors: connected.outgoing,\n      });\n    } else if (connected.outgoing.length === 0) {\n      connectivityWarnings.push({\n        code: \"no-outgoing-edges\",\n        message: `Executor ${executor.id} has no outgoing edges`,\n        executorId: executor.id,\n        connectedExecutors: connected.incoming,\n      });\n    }\n  }\n\n  return {\n    ...baseValidation,\n    typeErrors,\n    connectivityWarnings,\n  };\n}\n\n/**\n * Validate executor type\n */\nfunction validateExecutorType(\n  executor: BaseExecutor\n): TypeValidationError | null {\n  const validTypes: ExecutorType[] = [\n    \"executor\",\n    \"function-executor\",\n    \"workflow-executor\",\n    \"agent-executor\",\n    \"request-info-executor\",\n    \"magentic-agent-executor\",\n    \"magentic-orchestrator-executor\",\n  ];\n\n  if (!validTypes.includes(executor.type as ExecutorType)) {\n    return {\n      code: \"invalid-executor-type\",\n      message: `Invalid executor type: ${executor.type}`,\n      executorId: executor.id,\n      expectedType: validTypes.join(\" | \"),\n      actualType: executor.type,\n    };\n  }\n\n  return null;\n}\n\n/**\n * Validate edge compatibility between executors\n */\nfunction validateEdgeCompatibility(\n  source: BaseExecutor,\n  target: BaseExecutor,\n  edge: { id: string }\n): TypeValidationError | null {\n  // Basic compatibility checks\n  // In a full implementation, this would check message type compatibility\n  // For now, we just ensure both executors exist and are valid\n\n  // Check if source executor can produce messages\n  // Check if target executor can consume messages from source\n  // This is a simplified check - actual implementation would need\n  // to validate message type compatibility\n\n  return null;\n}\n\n/**\n * Get connected executors for a given executor\n */\nfunction getConnectedExecutors(\n  workflow: Workflow,\n  executorId: string\n): {\n  incoming: string[];\n  outgoing: string[];\n} {\n  const incoming = workflow.edges\n    .filter((e) => e.target === executorId)\n    .map((e) => e.source);\n  const outgoing = workflow.edges\n    .filter((e) => e.source === executorId)\n    .map((e) => e.target);\n\n  return { incoming, outgoing };\n}\n\n/**\n * Validate workflow schema against expected structure\n */\nexport function validateWorkflowSchema(workflow: unknown): {\n  valid: boolean;\n  errors: string[];\n} {\n  const errors: string[] = [];\n\n  if (!workflow || typeof workflow !== \"object\") {\n    errors.push(\"Workflow must be an object\");\n    return { valid: false, errors };\n  }\n\n  const wf = workflow as Record<string, unknown>;\n\n  if (!wf.id || typeof wf.id !== \"string\") {\n    errors.push(\"Workflow must have a string 'id' property\");\n  }\n\n  if (wf.executors) {\n    if (!Array.isArray(wf.executors)) {\n      errors.push(\"Workflow 'executors' must be an array\");\n    } else {\n      wf.executors.forEach((executor, idx) => {\n        if (!executor || typeof executor !== \"object\") {\n          errors.push(`Executor at index ${idx} must be an object`);\n        } else {\n          const exec = executor as Record<string, unknown>;\n          if (!exec.id || typeof exec.id !== \"string\") {\n            errors.push(`Executor at index ${idx} must have a string 'id' property`);\n          }\n          if (!exec.type || typeof exec.type !== \"string\") {\n            errors.push(`Executor at index ${idx} must have a string 'type' property`);\n          }\n        }\n      });\n    }\n  }\n\n  if (wf.edges) {\n    if (!Array.isArray(wf.edges)) {\n      errors.push(\"Workflow 'edges' must be an array\");\n    } else {\n      wf.edges.forEach((edge, idx) => {\n        if (!edge || typeof edge !== \"object\") {\n          errors.push(`Edge at index ${idx} must be an object`);\n        } else {\n          const e = edge as Record<string, unknown>;\n          if (!e.id || typeof e.id !== \"string\") {\n            errors.push(`Edge at index ${idx} must have a string 'id' property`);\n          }\n          if (!e.source || typeof e.source !== \"string\") {\n            errors.push(`Edge at index ${idx} must have a string 'source' property`);\n          }\n          if (!e.target || typeof e.target !== \"string\") {\n            errors.push(`Edge at index ${idx} must have a string 'target' property`);\n          }\n        }\n      });\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n  };\n}\n"],"names":[],"mappings":";;;;;;AAMA;;AAqCO,SAAS,yBACd,QAAkB;IAElB,MAAM,iBAAiB,IAAA,kJAAyB,EAAC;IACjD,MAAM,aAAoC,EAAE;IAC5C,MAAM,uBAA8C,EAAE;IAEtD,0BAA0B;IAC1B,KAAK,MAAM,YAAY,SAAS,SAAS,CAAE;QACzC,MAAM,YAAY,qBAAqB;QACvC,IAAI,WAAW;YACb,WAAW,IAAI,CAAC;QAClB;IACF;IAEA,mCAAmC;IACnC,KAAK,MAAM,QAAQ,SAAS,KAAK,CAAE;QACjC,MAAM,iBAAiB,SAAS,SAAS,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK,KAAK,MAAM;QAC1E,MAAM,iBAAiB,SAAS,SAAS,CAAC,IAAI,CAAC,CAAC,IAAM,EAAE,EAAE,KAAK,KAAK,MAAM;QAE1E,IAAI,kBAAkB,gBAAgB;YACpC,MAAM,qBAAqB,0BACzB,gBACA,gBACA;YAEF;;QAGF;IACF;IAEA,qBAAqB;IACrB,KAAK,MAAM,YAAY,SAAS,SAAS,CAAE;QACzC,MAAM,YAAY,sBAAsB,UAAU,SAAS,EAAE;QAC7D,IAAI,UAAU,QAAQ,CAAC,MAAM,KAAK,KAAK,UAAU,QAAQ,CAAC,MAAM,KAAK,GAAG;YACtE,qBAAqB,IAAI,CAAC;gBACxB,MAAM;gBACN,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,6BAA6B,CAAC;gBAC/D,YAAY,SAAS,EAAE;YACzB;QACF,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM,KAAK,GAAG;YAC1C,qBAAqB,IAAI,CAAC;gBACxB,MAAM;gBACN,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,sBAAsB,CAAC;gBACxD,YAAY,SAAS,EAAE;gBACvB,oBAAoB,UAAU,QAAQ;YACxC;QACF,OAAO,IAAI,UAAU,QAAQ,CAAC,MAAM,KAAK,GAAG;YAC1C,qBAAqB,IAAI,CAAC;gBACxB,MAAM;gBACN,SAAS,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,sBAAsB,CAAC;gBACxD,YAAY,SAAS,EAAE;gBACvB,oBAAoB,UAAU,QAAQ;YACxC;QACF;IACF;IAEA,OAAO;QACL,GAAG,cAAc;QACjB;QACA;IACF;AACF;AAEA;;CAEC,GACD,SAAS,qBACP,QAAsB;IAEtB,MAAM,aAA6B;QACjC;QACA;QACA;QACA;QACA;QACA;QACA;KACD;IAED,IAAI,CAAC,WAAW,QAAQ,CAAC,SAAS,IAAI,GAAmB;QACvD,OAAO;YACL,MAAM;YACN,SAAS,CAAC,uBAAuB,EAAE,SAAS,IAAI,EAAE;YAClD,YAAY,SAAS,EAAE;YACvB,cAAc,WAAW,IAAI,CAAC;YAC9B,YAAY,SAAS,IAAI;QAC3B;IACF;IAEA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,0BACP,MAAoB,EACpB,MAAoB,EACpB,IAAoB;IAEpB,6BAA6B;IAC7B,wEAAwE;IACxE,6DAA6D;IAE7D,gDAAgD;IAChD,4DAA4D;IAC5D,gEAAgE;IAChE,yCAAyC;IAEzC,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,sBACP,QAAkB,EAClB,UAAkB;IAKlB,MAAM,WAAW,SAAS,KAAK,CAC5B,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,YAC3B,GAAG,CAAC,CAAC,IAAM,EAAE,MAAM;IACtB,MAAM,WAAW,SAAS,KAAK,CAC5B,MAAM,CAAC,CAAC,IAAM,EAAE,MAAM,KAAK,YAC3B,GAAG,CAAC,CAAC,IAAM,EAAE,MAAM;IAEtB,OAAO;QAAE;QAAU;IAAS;AAC9B;AAKO,SAAS,uBAAuB,QAAiB;IAItD,MAAM,SAAmB,EAAE;IAE3B,IAAI,CAAC,YAAY,OAAO,aAAa,UAAU;QAC7C,OAAO,IAAI,CAAC;QACZ,OAAO;YAAE,OAAO;YAAO;QAAO;IAChC;IAEA,MAAM,KAAK;IAEX,IAAI,CAAC,GAAG,EAAE,IAAI,OAAO,GAAG,EAAE,KAAK,UAAU;QACvC,OAAO,IAAI,CAAC;IACd;IAEA,IAAI,GAAG,SAAS,EAAE;QAChB,IAAI,CAAC,MAAM,OAAO,CAAC,GAAG,SAAS,GAAG;YAChC,OAAO,IAAI,CAAC;QACd,OAAO;YACL,GAAG,SAAS,CAAC,OAAO,CAAC,CAAC,UAAU;gBAC9B,IAAI,CAAC,YAAY,OAAO,aAAa,UAAU;oBAC7C,OAAO,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,kBAAkB,CAAC;gBAC1D,OAAO;oBACL,MAAM,OAAO;oBACb,IAAI,CAAC,KAAK,EAAE,IAAI,OAAO,KAAK,EAAE,KAAK,UAAU;wBAC3C,OAAO,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,iCAAiC,CAAC;oBACzE;oBACA,IAAI,CAAC,KAAK,IAAI,IAAI,OAAO,KAAK,IAAI,KAAK,UAAU;wBAC/C,OAAO,IAAI,CAAC,CAAC,kBAAkB,EAAE,IAAI,mCAAmC,CAAC;oBAC3E;gBACF;YACF;QACF;IACF;IAEA,IAAI,GAAG,KAAK,EAAE;QACZ,IAAI,CAAC,MAAM,OAAO,CAAC,GAAG,KAAK,GAAG;YAC5B,OAAO,IAAI,CAAC;QACd,OAAO;YACL,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM;gBACtB,IAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;oBACrC,OAAO,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,kBAAkB,CAAC;gBACtD,OAAO;oBACL,MAAM,IAAI;oBACV,IAAI,CAAC,EAAE,EAAE,IAAI,OAAO,EAAE,EAAE,KAAK,UAAU;wBACrC,OAAO,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,iCAAiC,CAAC;oBACrE;oBACA,IAAI,CAAC,EAAE,MAAM,IAAI,OAAO,EAAE,MAAM,KAAK,UAAU;wBAC7C,OAAO,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,qCAAqC,CAAC;oBACzE;oBACA,IAAI,CAAC,EAAE,MAAM,IAAI,OAAO,EAAE,MAAM,KAAK,UAAU;wBAC7C,OAAO,IAAI,CAAC,CAAC,cAAc,EAAE,IAAI,qCAAqC,CAAC;oBACzE;gBACF;YACF;QACF;IACF;IAEA,OAAO;QACL,OAAO,OAAO,MAAM,KAAK;QACzB;IACF;AACF","debugId":null}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/conversion.ts"],"sourcesContent":["import type { Node as ReactFlowNode, Edge as ReactFlowEdge } from \"@xyflow/react\";\nimport type { BaseExecutor, BaseEdge, ExecutorId, EdgeId, EdgeCondition } from \"./types\";\nimport type { Workflow } from \"./workflow\";\nimport type {\n  FunctionExecutor,\n  AgentExecutor,\n  WorkflowExecutor,\n  RequestInfoExecutor,\n  ExecutorType,\n  MagenticAgentExecutor,\n  MagenticOrchestratorExecutor,\n  ToolReference,\n} from \"./executors\";\nimport type {\n  SingleEdgeGroup,\n  FanInEdgeGroup,\n  FanOutEdgeGroup,\n  SwitchCaseEdgeGroup,\n  EdgeGroup,\n} from \"./edges\";\nimport type { ExecutorNodeData } from \"@/components/ai-elements/executors/executor-node\";\nimport type { FunctionExecutorNodeData } from \"@/components/ai-elements/executors/function-executor-node\";\nimport type { AgentExecutorNodeData } from \"@/components/ai-elements/executors/agent-executor-node\";\nimport type { WorkflowExecutorNodeData } from \"@/components/ai-elements/executors/workflow-executor-node\";\nimport type { RequestInfoExecutorNodeData } from \"@/components/ai-elements/executors/request-info-executor-node\";\nimport type { FanInNodeData } from \"@/components/ai-elements/edge-groups/fan-in-node\";\nimport type { FanOutNodeData } from \"@/components/ai-elements/edge-groups/fan-out-node\";\nimport type { SwitchCaseNodeData } from \"@/components/ai-elements/edge-groups/switch-case-node\";\n\n// Import legacy node data types\nimport type {\n  WorkflowStepNodeData,\n  TextBlockNodeData,\n  AttributeNodeData,\n} from \"./types\";\nimport { MAGENTIC_AGENT_PRESET_MAP } from \"./magentic-presets\";\nimport type { MagenticAgentPresetKey } from \"./magentic-presets\";\n\n/**\n * Extended React Flow node data that can contain executor or edge group data\n */\nexport type WorkflowNodeData =\n  | ExecutorNodeData\n  | FunctionExecutorNodeData\n  | AgentExecutorNodeData\n  | WorkflowExecutorNodeData\n  | RequestInfoExecutorNodeData\n  | FanInNodeData\n  | FanOutNodeData\n  | SwitchCaseNodeData\n  | WorkflowStepNodeData\n  | TextBlockNodeData\n  | AttributeNodeData;\n\n/**\n * Workflow node data with index signature to satisfy ReactFlow constraints\n */\nexport type WorkflowNodeDataWithIndex = WorkflowNodeData & Record<string, unknown>;\n\n/**\n * React Flow node with workflow data\n */\nexport type WorkflowReactFlowNode = ReactFlowNode<WorkflowNodeDataWithIndex>;\n\n/**\n * React Flow edge with workflow data\n */\nexport type WorkflowReactFlowEdge = ReactFlowEdge;\n\n/**\n * Convert React Flow nodes and edges to Agent Framework Workflow format\n */\nexport function reactFlowToWorkflow(\n  nodes: WorkflowReactFlowNode[],\n  edges: WorkflowReactFlowEdge[],\n  workflowId: string = \"workflow-1\",\n  workflowName?: string\n): Workflow {\n  // Extract executors from nodes\n  const executors: BaseExecutor[] = [];\n  const nodePositions: Record<string, { x: number; y: number }> = {};\n\n  for (const node of nodes) {\n    // Store position for later restoration\n    nodePositions[node.id] = node.position;\n\n    // Handle executor nodes\n    if (isExecutorNodeData(node.data)) {\n      const executor = nodeToExecutor(node);\n      if (executor) {\n        // Store position in metadata\n        if (!executor.metadata) {\n          executor.metadata = {};\n        }\n        executor.metadata.position = node.position;\n        executors.push(executor);\n      }\n    }\n    // Edge groups are handled separately - they're represented as nodes but contain edge group data\n  }\n\n  // Convert edges\n  const workflowEdges: BaseEdge[] = edges.map((edge) => {\n    const condition = edge.data?.condition as EdgeCondition | undefined;\n    let edgeCondition: EdgeCondition | undefined = undefined;\n    \n    if (condition) {\n      if (condition.type === \"predicate\") {\n        edgeCondition = {\n          type: \"predicate\" as const,\n          expression: condition.expression,\n        };\n      } else if (condition.type === \"case\") {\n        edgeCondition = {\n          type: \"case\" as const,\n          caseValue: condition.caseValue,\n        };\n      }\n    }\n\n    return {\n      id: edge.id,\n      source: edge.source,\n      target: edge.target,\n      condition: edgeCondition,\n      metadata: {\n        ...edge.data,\n        type: edge.type,\n      },\n    };\n  });\n\n  // Extract edge groups from nodes\n  const edgeGroups: EdgeGroup[] = [];\n  for (const node of nodes) {\n    if (isEdgeGroupNode(node.data)) {\n      const group = nodeDataToEdgeGroup(node.data);\n      if (group) {\n        edgeGroups.push(group);\n      }\n    }\n  }\n\n  return {\n    id: workflowId,\n    name: workflowName,\n    executors,\n    edges: workflowEdges,\n    edgeGroups: edgeGroups.length > 0 ? edgeGroups : undefined,\n    metadata: (() => {\n      const metadata: Workflow[\"metadata\"] = {\n        createdAt: new Date().toISOString(),\n        custom: {},\n      };\n\n      if (Object.keys(nodePositions).length > 0) {\n        (metadata.custom as Record<string, unknown>).nodePositions = nodePositions;\n        (metadata as Record<string, unknown>).nodePositions = nodePositions;\n      }\n\n      if (!metadata.custom || Object.keys(metadata.custom).length === 0) {\n        delete metadata.custom;\n      }\n\n      return metadata;\n    })(),\n  };\n}\n\n/**\n * Convert Agent Framework Workflow format to React Flow nodes and edges\n */\nexport function workflowToReactFlow(workflow: Workflow): {\n  nodes: WorkflowReactFlowNode[];\n  edges: WorkflowReactFlowEdge[];\n} {\n  const nodes: WorkflowReactFlowNode[] = [];\n  const edges: WorkflowReactFlowEdge[] = [];\n\n  // Convert executors to nodes\n  for (const executor of workflow.executors) {\n    const nodePositions =\n      (workflow.metadata?.custom?.nodePositions as Record<string, { x: number; y: number }> | undefined) ??\n      ((workflow.metadata as Record<string, unknown> | undefined)?.nodePositions as Record<string, { x: number; y: number }> | undefined);\n    const position =\n      nodePositions?.[executor.id] ||\n      ({ x: 0, y: 0 } as { x: number; y: number });\n\n    const nodeData = executorToNodeData(executor);\n    if (nodeData) {\n      nodes.push({\n        id: executor.id,\n        type: getNodeTypeFromExecutor(executor),\n        position,\n        data: nodeData as WorkflowNodeDataWithIndex,\n      });\n    }\n  }\n\n  // Convert edge groups to nodes if they exist\n  if (workflow.edgeGroups) {\n    for (const group of workflow.edgeGroups) {\n      const nodeData = edgeGroupToNodeData(group);\n      if (nodeData) {\n        // Position edge group nodes (would need layout logic in real implementation)\n        const position = { x: 0, y: 0 };\n        nodes.push({\n          id: group.id,\n          type: getNodeTypeFromEdgeGroup(group),\n          position,\n          data: nodeData as WorkflowNodeDataWithIndex,\n        });\n      }\n    }\n  }\n\n  // Convert edges\n  for (const edge of workflow.edges) {\n    edges.push({\n      id: edge.id,\n      source: edge.source,\n      target: edge.target,\n      type: \"animated\",\n      data: {\n        condition: edge.condition,\n        ...edge.metadata,\n      },\n    });\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Check if node data is executor data\n */\nfunction isExecutorNodeData(\n  data: WorkflowNodeData\n): data is\n  | ExecutorNodeData\n  | FunctionExecutorNodeData\n  | AgentExecutorNodeData\n  | WorkflowExecutorNodeData\n  | RequestInfoExecutorNodeData {\n  return (\n    data.variant === \"executor\" ||\n    data.variant === \"function-executor\" ||\n    data.variant === \"agent-executor\" ||\n    data.variant === \"workflow-executor\" ||\n    data.variant === \"request-info-executor\"\n  );\n}\n\n/**\n * Check if node data is edge group data\n */\nfunction isEdgeGroupNode(\n  data: WorkflowNodeData\n): data is FanInNodeData | FanOutNodeData | SwitchCaseNodeData {\n  return (\n    data.variant === \"fan-in\" ||\n    data.variant === \"fan-out\" ||\n    data.variant === \"switch-case\"\n  );\n}\n\n/**\n * Convert React Flow node to executor\n */\nfunction nodeToExecutor(node: WorkflowReactFlowNode): BaseExecutor | null {\n  const data = node.data;\n  if (!isExecutorNodeData(data)) {\n    return null;\n  }\n\n  if (data.executor) {\n    return { ...data.executor };\n  }\n\n  // Fallback: create basic executor from node\n  return {\n    id: node.id,\n    type: (data.executorType as string) || \"executor\",\n    label: data.label,\n    description: data.description,\n  };\n}\n\n/**\n * Convert executor to React Flow node data\n */\nfunction executorToNodeData(\n  executor: BaseExecutor\n): WorkflowNodeData | null {\n  const executorType = executor.type as ExecutorType;\n\n  switch (executorType) {\n    case \"function-executor\": {\n      const funcExec = executor as FunctionExecutor;\n      return {\n        variant: \"function-executor\",\n        handles: { target: true, source: true },\n        executor: funcExec,\n        label: funcExec.label,\n        description: funcExec.description,\n      } as FunctionExecutorNodeData;\n    }\n    case \"agent-executor\": {\n      const agentExec = executor as AgentExecutor;\n      return {\n        variant: \"agent-executor\",\n        handles: { target: true, source: true },\n        executor: agentExec,\n        label: agentExec.label,\n        description: agentExec.description,\n      } as AgentExecutorNodeData;\n    }\n    case \"magentic-agent-executor\": {\n      const magenticAgent = executor as MagenticAgentExecutor;\n      return {\n        variant: \"agent-executor\",\n        handles: { target: true, source: true },\n        executor: magenticAgent as unknown as AgentExecutor,\n        label: magenticAgent.label,\n        description: magenticAgent.description,\n      } as AgentExecutorNodeData;\n    }\n    case \"workflow-executor\": {\n      const workflowExec = executor as WorkflowExecutor;\n      return {\n        variant: \"workflow-executor\",\n        handles: { target: true, source: true },\n        executor: workflowExec,\n        label: workflowExec.label,\n        description: workflowExec.description,\n      } as WorkflowExecutorNodeData;\n    }\n    case \"request-info-executor\": {\n      const reqExec = executor as RequestInfoExecutor;\n      return {\n        variant: \"request-info-executor\",\n        handles: { target: true, source: true },\n        executor: reqExec,\n        label: reqExec.label,\n        description: reqExec.description,\n      } as RequestInfoExecutorNodeData;\n    }\n    case \"magentic-orchestrator-executor\": {\n      const magenticOrchestrator = executor as MagenticOrchestratorExecutor;\n      return {\n        variant: \"executor\",\n        handles: { target: true, source: true },\n        executor: magenticOrchestrator as unknown as BaseExecutor,\n        executorType: \"magentic-orchestrator-executor\",\n        label: magenticOrchestrator.label,\n        description: magenticOrchestrator.description,\n      } as ExecutorNodeData;\n    }\n    default: {\n      if ((executor as BaseExecutor).type === \"magentic-agent-executor\") {\n        const magAgent = executor as MagenticAgentExecutor;\n        return {\n          variant: \"agent-executor\",\n          handles: { target: true, source: true },\n          executor: magAgent as unknown as AgentExecutor,\n          label: magAgent.label,\n          description: magAgent.description,\n        } as AgentExecutorNodeData;\n      }\n      if ((executor as BaseExecutor).type === \"magentic-orchestrator-executor\") {\n        const magOrchestrator = executor as MagenticOrchestratorExecutor;\n        return {\n          variant: \"executor\",\n          handles: { target: true, source: true },\n          executor: magOrchestrator as unknown as BaseExecutor,\n          executorType: \"magentic-orchestrator-executor\",\n          label: magOrchestrator.label,\n          description: magOrchestrator.description,\n        } as ExecutorNodeData;\n      }\n      return {\n        variant: \"executor\",\n        handles: { target: true, source: true },\n        executor,\n        executorType: executorType || \"executor\",\n        label: executor.label,\n        description: executor.description,\n      } as ExecutorNodeData;\n    }\n  }\n}\n\n/**\n * Get React Flow node type from executor\n */\nfunction getNodeTypeFromExecutor(executor: BaseExecutor): string {\n  const executorType = executor.type as ExecutorType;\n  switch (executorType) {\n    case \"function-executor\":\n      return \"function-executor\";\n    case \"agent-executor\":\n      return \"agent-executor\";\n    case \"magentic-agent-executor\":\n      return \"magentic-agent-executor\";\n    case \"workflow-executor\":\n      return \"workflow-executor\";\n    case \"request-info-executor\":\n      return \"request-info-executor\";\n    case \"magentic-orchestrator-executor\":\n      return \"magentic-orchestrator-executor\";\n    default:\n      return \"executor\";\n  }\n}\n\n/**\n * Convert node data to edge group\n */\nfunction nodeDataToEdgeGroup(\n  data: WorkflowNodeData\n): EdgeGroup | null {\n  if (data.variant === \"fan-in\" && \"group\" in data) {\n    return (data as FanInNodeData).group;\n  }\n  if (data.variant === \"fan-out\" && \"group\" in data) {\n    return (data as FanOutNodeData).group;\n  }\n  if (data.variant === \"switch-case\" && \"group\" in data) {\n    return (data as SwitchCaseNodeData).group;\n  }\n  return null;\n}\n\n/**\n * Convert edge group to node data\n */\nfunction edgeGroupToNodeData(group: EdgeGroup): WorkflowNodeData | null {\n  switch (group.type) {\n    case \"fan-in\": {\n      const fanIn = group as FanInEdgeGroup;\n      return {\n        variant: \"fan-in\",\n        handles: {\n          target: true,\n          source: true,\n          sourceCount: fanIn.sources.length,\n        },\n        group: fanIn,\n      } as FanInNodeData;\n    }\n    case \"fan-out\": {\n      const fanOut = group as FanOutEdgeGroup;\n      return {\n        variant: \"fan-out\",\n        handles: {\n          target: true,\n          source: true,\n          targetCount: fanOut.targets.length,\n        },\n        group: fanOut,\n      } as FanOutNodeData;\n    }\n    case \"switch-case\": {\n      const switchCase = group as SwitchCaseEdgeGroup;\n      return {\n        variant: \"switch-case\",\n        handles: {\n          target: true,\n          source: true,\n          caseCount: switchCase.cases.length,\n        },\n        group: switchCase,\n      } as SwitchCaseNodeData;\n    }\n    default:\n      return null;\n  }\n}\n\n/**\n * Get React Flow node type from edge group\n */\nfunction getNodeTypeFromEdgeGroup(group: EdgeGroup): string {\n  switch (group.type) {\n    case \"fan-in\":\n      return \"fan-in\";\n    case \"fan-out\":\n      return \"fan-out\";\n    case \"switch-case\":\n      return \"switch-case\";\n    default:\n      return \"executor\";\n  }\n}\n\n/**\n * Create default executor from node type\n */\ninterface CreateExecutorOptions {\n  label?: string;\n  presetKey?: string;\n}\n\nexport function createExecutorFromNodeType(\n  nodeType: string,\n  id: string,\n  label?: string,\n  options?: CreateExecutorOptions\n): BaseExecutor {\n  switch (nodeType) {\n    case \"function-executor\":\n      return {\n        id,\n        type: \"function-executor\",\n        label: label || \"Function Executor\",\n        description: \"Execute a function as a workflow node\",\n      } as FunctionExecutor;\n    case \"agent-executor\":\n      return {\n        id,\n        type: \"agent-executor\",\n        label: label || \"Agent Executor\",\n        description: \"Use an AI agent to process messages\",\n      } as AgentExecutor;\n    case \"workflow-executor\":\n      return {\n        id,\n        type: \"workflow-executor\",\n        label: label || \"Workflow Executor\",\n        description: \"Nest another workflow as an executor\",\n        workflowId: \"\",\n      } as WorkflowExecutor;\n    case \"request-info-executor\":\n      return {\n        id,\n        type: \"request-info-executor\",\n        label: label || \"Request Info Executor\",\n        description: \"Gateway for external information requests\",\n        requestType: \"\",\n      } as RequestInfoExecutor;\n    case \"magentic-orchestrator-executor\": {\n      return {\n        id,\n        type: \"magentic-orchestrator-executor\",\n        label: label || \"Magentic Orchestrator\",\n        description: \"Coordinates Magentic agents, planning and routing messages\",\n        planningStrategy: \"adaptive\",\n        progressTracking: true,\n        humanInTheLoop: false,\n        metadata: {\n          source: \"agent-framework\",\n          magentic: {\n            presetKey: \"orchestrator\",\n            planningStrategy: \"adaptive\",\n            progressTracking: true,\n            humanInTheLoop: false,\n          },\n        },\n      } as MagenticOrchestratorExecutor;\n    }\n    case \"magentic-agent-executor\": {\n      const preset =\n        options?.presetKey && MAGENTIC_AGENT_PRESET_MAP[options.presetKey as MagenticAgentPresetKey]\n          ? MAGENTIC_AGENT_PRESET_MAP[options.presetKey as MagenticAgentPresetKey]\n          : undefined;\n\n      return {\n        id,\n        type: \"magentic-agent-executor\",\n        label: label || preset?.label || \"Magentic Agent\",\n        description:\n          preset?.description || \"Specialised Magentic agent that collaborates under the orchestrator\",\n        agentRole: preset?.agentRole || \"generalist\",\n        capabilities: preset?.capabilities,\n        systemPrompt: preset?.systemPrompt,\n        tools: preset?.toolIds?.map((toolId) => ({ toolId, enabled: true } as ToolReference)),\n        metadata: {\n          source: \"agent-framework\",\n          magentic: {\n            presetKey: preset?.key ?? null,\n            agentRole: preset?.agentRole || \"generalist\",\n            capabilities: preset?.capabilities ?? [],\n            toolIds: preset?.toolIds ?? [],\n          },\n        },\n      } as MagenticAgentExecutor;\n    }\n    default:\n      return {\n        id,\n        type: \"executor\",\n        label: label || \"Executor\",\n        description: \"Base executor for processing messages\",\n      };\n  }\n}\n\n/**\n * Create default node data from executor type\n */\nexport function createNodeDataFromExecutorType(\n  executorType: ExecutorType,\n  executor: BaseExecutor\n): WorkflowNodeData {\n  switch (executorType) {\n    case \"function-executor\":\n      return {\n        variant: \"function-executor\",\n        handles: { target: true, source: true },\n        executor: executor as FunctionExecutor,\n      } as FunctionExecutorNodeData;\n    case \"agent-executor\":\n      return {\n        variant: \"agent-executor\",\n        handles: { target: true, source: true },\n        executor: executor as AgentExecutor,\n      } as AgentExecutorNodeData;\n    case \"magentic-agent-executor\":\n      return {\n        variant: \"agent-executor\",\n        handles: { target: true, source: true },\n        executor: executor as MagenticAgentExecutor,\n      } as AgentExecutorNodeData;\n    case \"workflow-executor\":\n      return {\n        variant: \"workflow-executor\",\n        handles: { target: true, source: true },\n        executor: executor as WorkflowExecutor,\n      } as WorkflowExecutorNodeData;\n    case \"request-info-executor\":\n      return {\n        variant: \"request-info-executor\",\n        handles: { target: true, source: true },\n        executor: executor as RequestInfoExecutor,\n      } as RequestInfoExecutorNodeData;\n    case \"magentic-orchestrator-executor\":\n      return {\n        variant: \"executor\",\n        handles: { target: true, source: true },\n        executor: executor as MagenticOrchestratorExecutor,\n        executorType: \"magentic-orchestrator-executor\",\n      } as ExecutorNodeData;\n    default:\n      return {\n        variant: \"executor\",\n        handles: { target: true, source: true },\n        executor,\n        executorType: \"executor\",\n      } as ExecutorNodeData;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1362, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/lib/workflow/types.ts"],"sourcesContent":["export type WorkflowNodeVariant = \"workflow\" | \"textBlock\" | \"attribute\";\n\n// ============================================================================\n// Agent Framework Base Types\n// ============================================================================\n\n/**\n * Unique identifier for an executor in a workflow\n */\nexport type ExecutorId = string;\n\n/**\n * Unique identifier for an edge in a workflow\n */\nexport type EdgeId = string;\n\n/**\n * Base executor interface - all workflow executors extend this\n */\nexport interface BaseExecutor {\n  id: ExecutorId;\n  type: string;\n  label?: string;\n  description?: string;\n  metadata?: Record<string, unknown>;\n  version?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  acl?: Acl;\n  status?: StatusFlag;\n}\n\n/**\n * Base edge interface - defines connections between executors\n */\nexport interface BaseEdge {\n  id: EdgeId;\n  source: ExecutorId;\n  target: ExecutorId;\n  condition?: EdgeCondition;\n  metadata?: Record<string, unknown>;\n  version?: string;\n  createdAt?: string;\n  updatedAt?: string;\n  acl?: Acl;\n  status?: StatusFlag;\n}\n\n/**\n * Edge condition for conditional routing\n */\nexport type EdgeCondition = {\n  type: \"predicate\" | \"case\";\n  expression?: string; // For predicate-based conditions\n  caseValue?: string; // For switch-case conditions\n};\n\n/**\n * Base message type - messages flow between executors\n */\nexport interface BaseMessage {\n  id: string;\n  type: string;\n  role?: MessageRole;\n  content?: unknown;\n  metadata?: Record<string, unknown>;\n  timestamp?: string;\n}\n\n/**\n * Message role in conversation\n */\nexport type MessageRole = \"system\" | \"user\" | \"assistant\" | \"tool\";\n\n/**\n * Workflow context - provides execution context for executors\n * Generic type T represents the message type flowing through the workflow\n */\nexport interface WorkflowContext<T extends BaseMessage = BaseMessage> {\n  executorId: ExecutorId;\n  messages: T[];\n  sharedState?: SharedState;\n  sendMessage: (target: ExecutorId, message: T) => void;\n  yieldOutput: (output: unknown) => void;\n  getState: <K extends keyof SharedState>(key: K) => SharedState[K] | undefined;\n  setState: <K extends keyof SharedState>(key: K, value: SharedState[K]) => void;\n}\n\n/**\n * Shared state across workflow executors\n */\nexport type SharedState = Record<string, unknown>;\n\n/**\n * Base edge group interface - groups of edges with routing logic\n */\nexport interface BaseEdgeGroup {\n  id: string;\n  type: EdgeGroupType;\n  edges: BaseEdge[];\n}\n\n/**\n * Edge group types\n */\nexport type EdgeGroupType =\n  | \"single\"\n  | \"fan-in\"\n  | \"fan-out\"\n  | \"switch-case\";\n\nexport type StatusFlag = \"draft\" | \"active\" | \"disabled\" | \"deprecated\";\n\nexport interface Acl {\n  owner: string;\n  read?: string[];\n  write?: string[];\n  roles?: string[];\n}\n\n/**\n * Finish reason for chat responses\n */\nexport type FinishReason =\n  | \"stop\"\n  | \"length\"\n  | \"tool_calls\"\n  | \"content_filter\"\n  | \"function_call\";\n\n/**\n * Tool mode for agent execution\n */\nexport type ToolMode = \"auto\" | \"required\" | \"none\";\n\nexport type WorkflowHandles = {\n  target: boolean;\n  source: boolean;\n};\n\nexport type WorkflowStepNodeData = {\n  variant: \"workflow\";\n  handles: WorkflowHandles;\n  label: string;\n  description: string;\n  content: string;\n  footer: string;\n};\n\nexport type TextBlockNodeData = {\n  variant: \"textBlock\";\n  handles: WorkflowHandles;\n  title: string;\n  model: string;\n  placeholder: string;\n  showSuggestions: boolean;\n  collapsed: boolean;\n};\n\nexport type AttributeType = \"input\" | \"progress\" | \"checkbox\" | \"select\" | \"slider\";\n\nexport type AttributeDefinition = {\n  id: string;\n  label: string;\n  type: AttributeType;\n  value?: unknown;\n  options?: string[];\n  min?: number;\n  max?: number;\n  step?: number;\n};\n\nexport type AttributeNodeData = {\n  variant: \"attribute\";\n  handles: WorkflowHandles;\n  title: string;\n  model: string;\n  attributes: AttributeDefinition[];\n  collapsed: boolean;\n};\n\nexport type WorkflowNodeData =\n  | WorkflowStepNodeData\n  | TextBlockNodeData\n  | AttributeNodeData;\n\nexport const defaultHandles: WorkflowHandles = {\n  target: true,\n  source: true,\n};\n\nexport const defaultWorkflowStepData = (\n  overrides: Partial<Omit<WorkflowStepNodeData, \"variant\">> = {}\n): WorkflowStepNodeData => ({\n  variant: \"workflow\",\n  handles: overrides.handles ?? defaultHandles,\n  label: overrides.label ?? \"New Step\",\n  description: overrides.description ?? \"Customize this workflow step\",\n  content:\n    overrides.content ??\n    \"Drag to reposition or connect to an existing node.\",\n  footer: overrides.footer ?? \"Status: Draft\",\n});\n\nexport const defaultTextBlockData = (\n  overrides: Partial<Omit<TextBlockNodeData, \"variant\">> = {}\n): TextBlockNodeData => ({\n  variant: \"textBlock\",\n  handles: overrides.handles ?? defaultHandles,\n  title: overrides.title ?? \"Text\",\n  model: overrides.model ?? \"GPT-5\",\n  placeholder:\n    overrides.placeholder ??\n    'Try \"A script excerpt of a romantic meeting in Paris\"',\n  showSuggestions: overrides.showSuggestions ?? true,\n  collapsed: overrides.collapsed ?? false,\n});\n\nexport const defaultAttributeNodeData = (\n  overrides: Partial<Omit<AttributeNodeData, \"variant\">> = {}\n): AttributeNodeData => ({\n  variant: \"attribute\",\n  handles: overrides.handles ?? defaultHandles,\n  title: overrides.title ?? \"Attributes\",\n  model: overrides.model ?? \"GPT-5\",\n  attributes: overrides.attributes ?? [],\n  collapsed: overrides.collapsed ?? false,\n});\n"],"names":[],"mappings":";;;;;;;;;;AA0LO,MAAM,iBAAkC;IAC7C,QAAQ;IACR,QAAQ;AACV;AAEO,MAAM,0BAA0B,CACrC,YAA4D,CAAC,CAAC,GACrC,CAAC;QAC1B,SAAS;QACT,SAAS,UAAU,OAAO,IAAI;QAC9B,OAAO,UAAU,KAAK,IAAI;QAC1B,aAAa,UAAU,WAAW,IAAI;QACtC,SACE,UAAU,OAAO,IACjB;QACF,QAAQ,UAAU,MAAM,IAAI;IAC9B,CAAC;AAEM,MAAM,uBAAuB,CAClC,YAAyD,CAAC,CAAC,GACrC,CAAC;QACvB,SAAS;QACT,SAAS,UAAU,OAAO,IAAI;QAC9B,OAAO,UAAU,KAAK,IAAI;QAC1B,OAAO,UAAU,KAAK,IAAI;QAC1B,aACE,UAAU,WAAW,IACrB;QACF,iBAAiB,UAAU,eAAe,IAAI;QAC9C,WAAW,UAAU,SAAS,IAAI;IACpC,CAAC;AAEM,MAAM,2BAA2B,CACtC,YAAyD,CAAC,CAAC,GACrC,CAAC;QACvB,SAAS;QACT,SAAS,UAAU,OAAO,IAAI;QAC9B,OAAO,UAAU,KAAK,IAAI;QAC1B,OAAO,UAAU,KAAK,IAAI;QAC1B,YAAY,UAAU,UAAU,IAAI,EAAE;QACtC,WAAW,UAAU,SAAS,IAAI;IACpC,CAAC","debugId":null}},
    {"offset": {"line": 1411, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/public/logo-lightmode.svg.mjs%20%28structured%20image%20object%20with%20data%20url%29"],"sourcesContent":["import src from \"IMAGE\";\nexport default { src, width: 25, height: 24, blurWidth: 0, blurHeight: 0};\n"],"names":[],"mappings":";;;;AAAA;;uCACe;IAAE,KAAA,gJAAG;IAAE,OAAO;IAAI,QAAQ;IAAI,WAAW;IAAG,YAAY;AAAC","debugId":null}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/public/logo-darkmode.svg.mjs%20%28structured%20image%20object%20with%20data%20url%29"],"sourcesContent":["import src from \"IMAGE\";\nexport default { src, width: 25, height: 24, blurWidth: 0, blurHeight: 0};\n"],"names":[],"mappings":";;;;AAAA;;uCACe;IAAE,KAAA,+IAAG;IAAE,OAAO;IAAI,QAAQ;IAAI,WAAW;IAAG,YAAY;AAAC","debugId":null}},
    {"offset": {"line": 1454, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Samsung-SSD-T7/Workspaces/Github/qredence/agent-framework/v0.5/agenticfabric%202/app/page.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { memo, useCallback, useRef, useState, useMemo, type DragEvent } from \"react\"\nimport {\n  ReactFlowProvider,\n  addEdge,\n  applyNodeChanges,\n  useEdgesState,\n  useNodesState,\n  useReactFlow,\n  type Connection,\n  type Edge,\n  type Node as ReactFlowNode,\n  type NodeChange,\n  type XYPosition,\n} from \"@xyflow/react\"\nimport { Canvas } from \"@/components/ai-elements/canvas\"\nimport { Connection as ConnectionLine } from \"@/components/ai-elements/connection\"\nimport { TemporaryEdge, AnimatedEdge } from \"@/components/ai-elements/edge\"\nimport { EdgeNodeDropdown } from \"@/components/workflow-builder/edge-node-dropdown\"\nimport { Node, NodeContent, NodeDescription, NodeFooter, NodeHeader, NodeTitle } from \"@/components/ai-elements/node\"\nimport { Toolbar } from \"@/components/ai-elements/toolbar\"\nimport { TextBlockCard } from \"@/components/ai-elements/text-block-card\"\nimport { AttributeNode } from \"@/components/ai-elements/attribute-node\"\nimport { Action, Actions } from \"@/components/ai-elements/actions\"\nimport { Pencil, Trash2 } from \"lucide-react\"\nimport { nanoid } from \"nanoid\"\n\n// Import executor node components\nimport { ExecutorNode } from \"@/components/ai-elements/executors/executor-node\"\nimport { FunctionExecutorNode } from \"@/components/ai-elements/executors/function-executor-node\"\nimport { AgentExecutorNode } from \"@/components/ai-elements/executors/agent-executor-node\"\nimport { WorkflowExecutorNode } from \"@/components/ai-elements/executors/workflow-executor-node\"\nimport { RequestInfoExecutorNode } from \"@/components/ai-elements/executors/request-info-executor-node\"\n\n// Import edge group components\nimport { FanInNode } from \"@/components/ai-elements/edge-groups/fan-in-node\"\nimport type { FanInNodeData } from \"@/components/ai-elements/edge-groups/fan-in-node\"\nimport { FanOutNode } from \"@/components/ai-elements/edge-groups/fan-out-node\"\nimport type { FanOutNodeData } from \"@/components/ai-elements/edge-groups/fan-out-node\"\nimport { SwitchCaseNode } from \"@/components/ai-elements/edge-groups/switch-case-node\"\nimport type { SwitchCaseNodeData } from \"@/components/ai-elements/edge-groups/switch-case-node\"\n\n// Import workflow builder components\nimport { NodeLibrary } from \"@/components/workflow-builder/node-library\"\nimport { PropertiesPanel } from \"@/components/workflow-builder/properties-panel\"\nimport { ExportDialog } from \"@/components/workflow-builder/export-dialog\"\nimport { ImportDialog } from \"@/components/workflow-builder/import-dialog\"\nimport { TopNavigation } from \"@/components/workflow-builder/top-navigation\"\nimport { BottomControls } from \"@/components/workflow-builder/bottom-controls\"\n\n// Import types and utilities\nimport type { AttributeNodeData, TextBlockNodeData, WorkflowStepNodeData } from \"@/lib/workflow/types\"\nimport { defaultAttributeNodeData, defaultTextBlockData, defaultWorkflowStepData } from \"@/lib/workflow/types\"\nimport type { WorkflowReactFlowNode, WorkflowNodeDataWithIndex } from \"@/lib/workflow/conversion\"\nimport {\n  reactFlowToWorkflow,\n  createExecutorFromNodeType,\n  createNodeDataFromExecutorType,\n} from \"@/lib/workflow/conversion\"\nimport type { FanInEdgeGroup, FanOutEdgeGroup, SwitchCaseEdgeGroup } from \"@/lib/workflow/edges\"\nimport type { ExecutorType } from \"@/lib/workflow/executors\"\nimport { MAGENTIC_AGENT_PRESETS } from \"@/lib/workflow/magentic-presets\"\nimport type { MagenticAgentPresetKey } from \"@/lib/workflow/magentic-presets\"\nimport type { BaseExecutor } from \"@/lib/workflow/types\"\n\ntype WorkflowNode = WorkflowReactFlowNode\ntype WorkflowEdge = Edge\n\nconst nodeIds = {\n  start: \"start\",\n  process1: \"process1\",\n  process2: \"process2\",\n  decision: \"decision\",\n  output1: \"output1\",\n  output2: \"output2\",\n  textBlock: \"textBlock\",\n  attribute: \"attribute\",\n}\n\nconst initialNodes: WorkflowNode[] = [\n  {\n    id: nodeIds.start,\n    type: \"workflow\",\n    position: { x: 0, y: 0 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: false, source: true },\n        label: \"Start\",\n        description: \"Initialize workflow\",\n        content: \"Triggered by user action at 09:30 AM\",\n        footer: \"Status: Ready\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.process1,\n    type: \"workflow\",\n    position: { x: 500, y: 0 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: true, source: true },\n        label: \"Process Data\",\n        description: \"Transform input\",\n        content: \"Validating 1,234 records and applying business rules\",\n        footer: \"Duration: ~2.5s\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.decision,\n    type: \"workflow\",\n    position: { x: 1000, y: 0 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: true, source: true },\n        label: \"Decision Point\",\n        description: \"Route based on conditions\",\n        content: \"Evaluating: data.status === 'valid' && data.score > 0.8\",\n        footer: \"Confidence: 94%\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.output1,\n    type: \"workflow\",\n    position: { x: 1500, y: -300 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: true, source: true },\n        label: \"Success Path\",\n        description: \"Handle success case\",\n        content: \"1,156 records passed validation (93.7%)\",\n        footer: \"Next: Send to production\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.output2,\n    type: \"workflow\",\n    position: { x: 1500, y: 300 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: true, source: true },\n        label: \"Error Path\",\n        description: \"Handle error case\",\n        content: \"78 records failed validation (6.3%)\",\n        footer: \"Next: Queue for review\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.process2,\n    type: \"workflow\",\n    position: { x: 2000, y: 0 },\n    data: {\n      ...defaultWorkflowStepData({\n        handles: { target: true, source: false },\n        label: \"Complete\",\n        description: \"Finalize workflow\",\n        content: \"All records processed and routed successfully\",\n        footer: \"Total time: 4.2s\",\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.textBlock,\n    type: \"textBlock\",\n    position: { x: 600, y: -250 },\n    data: {\n      ...defaultTextBlockData({\n        title: \"Creative brief\",\n        placeholder: \"Outline the project scope and key messaging\",\n        showSuggestions: true,\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n  {\n    id: nodeIds.attribute,\n    type: \"attribute\",\n    position: { x: 600, y: 250 },\n    data: {\n      ...defaultAttributeNodeData({\n        title: \"Generation settings\",\n        attributes: [\n          {\n            id: \"tone\",\n            label: \"Tone\",\n            type: \"select\",\n            options: [\"Formal\", \"Neutral\", \"Playful\"],\n            value: \"Neutral\",\n          },\n          {\n            id: \"temperature\",\n            label: \"Temperature\",\n            type: \"slider\",\n            min: 0,\n            max: 1,\n            step: 0.05,\n            value: 0.7,\n          },\n          {\n            id: \"length\",\n            label: \"Length\",\n            type: \"progress\",\n            value: 40,\n          },\n        ],\n      }),\n      ...{},\n    } as WorkflowNodeDataWithIndex,\n  },\n]\n\nconst initialEdges: WorkflowEdge[] = [\n  {\n    id: \"edge1\",\n    source: nodeIds.start,\n    target: nodeIds.process1,\n    type: \"animated\",\n  },\n  {\n    id: \"edge2\",\n    source: nodeIds.process1,\n    target: nodeIds.decision,\n    type: \"animated\",\n  },\n  {\n    id: \"edge3\",\n    source: nodeIds.decision,\n    target: nodeIds.output1,\n    type: \"animated\",\n  },\n  {\n    id: \"edge4\",\n    source: nodeIds.decision,\n    target: nodeIds.output2,\n    type: \"temporary\",\n  },\n  {\n    id: \"edge5\",\n    source: nodeIds.output1,\n    target: nodeIds.process2,\n    type: \"animated\",\n  },\n  {\n    id: \"edge6\",\n    source: nodeIds.output2,\n    target: nodeIds.process2,\n    type: \"temporary\",\n  },\n]\n\ntype EdgeGroupNodeType = \"fan-in\" | \"fan-out\" | \"switch-case\"\n\nconst isEdgeGroupNodeType = (nodeType: string): nodeType is EdgeGroupNodeType => {\n  return nodeType === \"fan-in\" || nodeType === \"fan-out\" || nodeType === \"switch-case\"\n}\n\nconst parseNodeTypeToken = (value: string): { baseType: string; presetKey?: MagenticAgentPresetKey } => {\n  const [baseType, preset] = value.split(\":\")\n  return {\n    baseType,\n    presetKey: preset as MagenticAgentPresetKey | undefined,\n  }\n}\n\nfunction createDefaultFanInGroup(id: string): FanInEdgeGroup {\n  return {\n    id,\n    type: \"fan-in\",\n    sources: [],\n    target: \"\",\n    edges: [],\n  }\n}\n\nfunction createDefaultFanOutGroup(id: string): FanOutEdgeGroup {\n  return {\n    id,\n    type: \"fan-out\",\n    source: \"\",\n    targets: [],\n    edges: [],\n    broadcastMode: \"parallel\",\n  }\n}\n\nfunction createDefaultSwitchCaseGroup(id: string): SwitchCaseEdgeGroup {\n  return {\n    id,\n    type: \"switch-case\",\n    source: \"\",\n    cases: [],\n    switchExpression: \"message.type\",\n  }\n}\n\nfunction createEdgeGroupNode(nodeType: EdgeGroupNodeType, position: XYPosition): WorkflowReactFlowNode {\n  const id = `${nodeType}-${nanoid()}`\n\n  if (nodeType === \"fan-in\") {\n    const group = createDefaultFanInGroup(id)\n    const data: FanInNodeData = {\n      variant: \"fan-in\",\n      handles: {\n        target: true,\n        source: true,\n        sourceCount: group.sources.length,\n      },\n      group,\n    }\n    return {\n      id,\n      type: nodeType,\n      position,\n      data: data as WorkflowNodeDataWithIndex,\n    }\n  }\n\n  if (nodeType === \"fan-out\") {\n    const group = createDefaultFanOutGroup(id)\n    const data: FanOutNodeData = {\n      variant: \"fan-out\",\n      handles: {\n        target: true,\n        source: true,\n        targetCount: group.targets.length,\n      },\n      group,\n    }\n    return {\n      id,\n      type: nodeType,\n      position,\n      data: data as WorkflowNodeDataWithIndex,\n    }\n  }\n\n  const group = createDefaultSwitchCaseGroup(id)\n  const data: SwitchCaseNodeData = {\n    variant: \"switch-case\",\n    handles: {\n      target: true,\n      source: true,\n      caseCount: group.cases.length,\n    },\n    group,\n  }\n  return {\n    id,\n    type: nodeType,\n    position,\n    data: data as WorkflowNodeDataWithIndex,\n  }\n}\n\nconst WorkflowStepNode = memo(({ id, data }: { id: string; data: WorkflowStepNodeData }) => (\n  <Node handles={data.handles}>\n    <NodeHeader>\n      <NodeTitle>{data.label}</NodeTitle>\n      <NodeDescription>{data.description}</NodeDescription>\n    </NodeHeader>\n    <NodeContent>\n      <p className=\"text-sm\">{data.content}</p>\n    </NodeContent>\n    <NodeFooter>\n      <p className=\"text-muted-foreground text-xs\">{data.footer}</p>\n    </NodeFooter>\n    <Toolbar>\n      <Actions>\n        <Action tooltip=\"Edit node\" label=\"Edit\" aria-label=\"Edit node\">\n          <Pencil className=\"size-4\" />\n        </Action>\n        <Action tooltip=\"Delete node\" label=\"Delete\" aria-label=\"Delete node\">\n          <Trash2 className=\"size-4\" />\n        </Action>\n      </Actions>\n    </Toolbar>\n  </Node>\n))\n\nconst TextBlockWorkflowNode = memo(\n  ({ id, data, selected }: { id: string; data: TextBlockNodeData; selected?: boolean }) => {\n    const { handles: _handles, ...cardProps } = data\n    void _handles\n\n    return <TextBlockCard {...cardProps} data-id={id} isSelected={selected} />\n  },\n)\n\nconst AttributeWorkflowNode = memo(\n  ({ id, data, selected }: { id: string; data: AttributeNodeData; selected?: boolean }) => {\n    const { handles: _handles, ...attributeProps } = data\n    void _handles\n\n    return <AttributeNode {...attributeProps} data-id={id} isSelected={selected} />\n  },\n)\n\nconst nodeTypes: Record<string, React.ComponentType<any>> = {\n  // Legacy node types (kept for backward compatibility)\n  workflow: WorkflowStepNode,\n  textBlock: TextBlockWorkflowNode,\n  attribute: AttributeWorkflowNode,\n  // New executor node types\n  executor: ExecutorNode,\n  \"function-executor\": FunctionExecutorNode,\n  \"agent-executor\": AgentExecutorNode,\n  \"magentic-agent-executor\": AgentExecutorNode,\n  \"workflow-executor\": WorkflowExecutorNode,\n  \"request-info-executor\": RequestInfoExecutorNode,\n  \"magentic-orchestrator-executor\": ExecutorNode,\n  // Edge group node types\n  \"fan-in\": FanInNode,\n  \"fan-out\": FanOutNode,\n  \"switch-case\": SwitchCaseNode,\n}\n\n// Create edge types with handlers\nconst createEdgeTypes = (\n  onEdgeHover?: (edgeId: string, position: XYPosition, screenPosition: { x: number; y: number }) => void,\n) => ({\n  animated: (props: any) => (\n    <AnimatedEdge\n      {...props}\n      onHover={\n        onEdgeHover\n          ? (pos: XYPosition, screenPos: { x: number; y: number }) => onEdgeHover(props.id, pos, screenPos)\n          : undefined\n      }\n    />\n  ),\n  temporary: TemporaryEdge,\n})\n\nconst edgeTypesBase = {\n  animated: AnimatedEdge,\n  temporary: TemporaryEdge,\n}\n\nconst WorkflowCanvas = () => {\n  const [nodes, setNodes] = useNodesState(initialNodes as any)\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges)\n  const reactFlow = useReactFlow()\n  const flowWrapperRef = useRef<HTMLDivElement>(null)\n\n  // State management for new features\n  const [selectedNode, setSelectedNode] = useState<ReactFlowNode<WorkflowNodeDataWithIndex> | null>(null)\n  const [exportDialogOpen, setExportDialogOpen] = useState(false)\n  const [importDialogOpen, setImportDialogOpen] = useState(false)\n  const [locked, setLocked] = useState(false)\n  const [draggedNodeId, setDraggedNodeId] = useState<string | null>(null)\n\n  // Undo/Redo history management\n  const [history, setHistory] = useState<Array<{ nodes: any[]; edges: Edge[] }>>([\n    { nodes: initialNodes as any[], edges: initialEdges },\n  ])\n  const [historyIndex, setHistoryIndex] = useState(0)\n\n  const canUndo = historyIndex > 0\n  const canRedo = historyIndex < history.length - 1\n\n  // Save state to history\n  const saveToHistory = useCallback(\n    (newNodes: any[], newEdges: Edge[]) => {\n      setHistory((prev) => {\n        const newHistory = prev.slice(0, historyIndex + 1)\n        newHistory.push({ nodes: JSON.parse(JSON.stringify(newNodes)), edges: JSON.parse(JSON.stringify(newEdges)) })\n        return newHistory.slice(-50) // Keep last 50 states\n      })\n      setHistoryIndex((prev) => Math.min(prev + 1, 49))\n    },\n    [historyIndex],\n  )\n\n  // Convert React Flow state to Workflow format\n  const currentWorkflow = useMemo(() => {\n    return reactFlowToWorkflow(nodes as any, edges, \"workflow-1\", \"Agentic Fabric\")\n  }, [nodes, edges])\n\n  // Handle node selection - wrapper to sync selected node state\n  const handleNodesChangeWrapper = useCallback(\n    (changes: NodeChange[]) => {\n      const nextNodes = applyNodeChanges(changes, nodes)\n      setNodes(nextNodes)\n\n      const significantChanges = changes.filter((change) => change.type !== \"select\" && change.type !== \"position\")\n      if (significantChanges.length > 0 && !draggedNodeId) {\n        saveToHistory(nextNodes, edges)\n      }\n\n      if (selectedNode) {\n        const updated = nextNodes.find((node) => node.id === selectedNode.id)\n        setSelectedNode(updated ? (updated as ReactFlowNode<WorkflowNodeDataWithIndex>) : null)\n      }\n    },\n    [nodes, selectedNode, setNodes, edges, saveToHistory, draggedNodeId],\n  )\n\n  const handleConnect = useCallback(\n    (connection: Connection) => {\n      setEdges((eds) => {\n        const newEdges = addEdge({ ...connection, type: \"animated\" }, eds)\n        saveToHistory(nodes, newEdges)\n        return newEdges\n      })\n    },\n    [setEdges, nodes, saveToHistory],\n  )\n\n  // Handle inserting node on edge\n  const [edgeDropdownState, setEdgeDropdownState] = useState<{\n    edgeId: string\n    position: XYPosition\n    screenPosition: { x: number; y: number }\n  } | null>(null)\n\n  const handleEdgeHover = useCallback(\n    (edgeId: string, position: XYPosition, screenPosition: { x: number; y: number }) => {\n      setEdgeDropdownState({\n        edgeId,\n        position,\n        screenPosition,\n      })\n    },\n    [],\n  )\n\n  const handleInsertNodeOnEdge = useCallback(\n    (nodeType: string) => {\n      if (!edgeDropdownState) return\n\n      const edge = edges.find((e) => e.id === edgeDropdownState.edgeId)\n      if (!edge) {\n        setEdgeDropdownState(null)\n        return\n      }\n\n      const position = edgeDropdownState.position\n      const { baseType, presetKey } = parseNodeTypeToken(nodeType)\n\n      // Create new node\n      setNodes((nds) => {\n        let newNode: ReactFlowNode<WorkflowNodeDataWithIndex>\n\n        if (isEdgeGroupNodeType(baseType)) {\n          newNode = createEdgeGroupNode(baseType, position)\n        } else {\n          const executorId = nanoid()\n          const preset = presetKey ? MAGENTIC_AGENT_PRESETS.find((item) => item.key === presetKey) : undefined\n          const executor = createExecutorFromNodeType(baseType, executorId, preset?.label || `New ${baseType}`, {\n            presetKey,\n          })\n          const nodeData = createNodeDataFromExecutorType(baseType as ExecutorType, executor)\n\n          newNode = {\n            id: executorId,\n            type: baseType,\n            position,\n            data: { ...nodeData, ...{} } as WorkflowNodeDataWithIndex,\n          }\n        }\n\n        const newNodes = [...nds, newNode]\n\n        // Split edge: remove old edge, add two new edges\n        setEdges((eds) => {\n          const filtered = eds.filter((e) => e.id !== edgeDropdownState.edgeId)\n          const newEdges = [\n            ...filtered,\n            { id: nanoid(), source: edge.source, target: newNode.id, type: \"animated\" },\n            { id: nanoid(), source: newNode.id, target: edge.target, type: \"animated\" },\n          ]\n          // Save to history after all changes\n          saveToHistory(newNodes, newEdges)\n          return newEdges\n        })\n\n        return newNodes\n      })\n\n      setEdgeDropdownState(null)\n    },\n    [edgeDropdownState, edges, setNodes, setEdges, saveToHistory],\n  )\n\n  const handleDragOver = useCallback((event: DragEvent<HTMLDivElement>) => {\n    event.preventDefault()\n    event.dataTransfer.dropEffect = \"move\"\n  }, [])\n\n  const handleDrop = useCallback(\n    (event: DragEvent<HTMLDivElement>) => {\n      event.preventDefault()\n      const nodeType = event.dataTransfer.getData(\"application/reactflow\")\n      if (!nodeType) {\n        return\n      }\n\n      const position = reactFlow.screenToFlowPosition({\n        x: event.clientX,\n        y: event.clientY,\n      })\n\n      setNodes((nds) => {\n        let newNode: ReactFlowNode<WorkflowNodeDataWithIndex>\n        const { baseType, presetKey } = parseNodeTypeToken(nodeType)\n\n        if (baseType === \"textBlock\") {\n          newNode = {\n            id: nanoid(),\n            type: baseType,\n            position,\n            data: { ...defaultTextBlockData(), ...{} } as WorkflowNodeDataWithIndex,\n          }\n        } else if (baseType === \"attribute\") {\n          newNode = {\n            id: nanoid(),\n            type: baseType,\n            position,\n            data: { ...defaultAttributeNodeData(), ...{} } as WorkflowNodeDataWithIndex,\n          }\n        } else if (baseType === \"workflow\") {\n          newNode = {\n            id: nanoid(),\n            type: baseType,\n            position,\n            data: {\n              ...defaultWorkflowStepData({\n                label: `New Step ${nds.length + 1}`,\n              }),\n              ...{},\n            } as WorkflowNodeDataWithIndex,\n          }\n        } else if (isEdgeGroupNodeType(baseType)) {\n          newNode = createEdgeGroupNode(baseType, position)\n        } else {\n          const executorId = nanoid()\n          const preset = presetKey ? MAGENTIC_AGENT_PRESETS.find((item) => item.key === presetKey) : undefined\n          const executor = createExecutorFromNodeType(baseType, executorId, preset?.label || `New ${baseType}`, {\n            presetKey,\n          })\n          const nodeData = createNodeDataFromExecutorType(baseType as ExecutorType, executor)\n\n          newNode = {\n            id: executorId,\n            type: baseType,\n            position,\n            data: { ...nodeData, ...{} } as WorkflowNodeDataWithIndex,\n          }\n        }\n\n        const newNodes = [...nds, newNode]\n        saveToHistory(newNodes, edges)\n        return newNodes\n      })\n    },\n    [reactFlow, setNodes, edges, saveToHistory],\n  )\n\n  const handleDragStart = useCallback((event: DragEvent<HTMLDivElement>, nodeType: string) => {\n    event.dataTransfer.setData(\"application/reactflow\", nodeType)\n    event.dataTransfer.effectAllowed = \"move\"\n  }, [])\n\n  const handleAddNode = useCallback(\n    (nodeType = \"executor\") => {\n      if (!flowWrapperRef.current) {\n        return\n      }\n\n      const bounds = flowWrapperRef.current.getBoundingClientRect()\n      const centerPosition = reactFlow.screenToFlowPosition({\n        x: bounds.left + bounds.width / 2,\n        y: bounds.top + bounds.height / 2,\n      })\n\n      setNodes((nds) => {\n        let newNode: ReactFlowNode<WorkflowNodeDataWithIndex>\n        const { baseType, presetKey } = parseNodeTypeToken(nodeType)\n\n        if (baseType === \"workflow\") {\n          newNode = {\n            id: nanoid(),\n            type: baseType,\n            position: centerPosition,\n            data: {\n              ...defaultWorkflowStepData({\n                label: `New Step ${nds.length + 1}`,\n                description: \"Added from panel\",\n                content: \"Start connecting this step to build out the workflow.\",\n              }),\n              ...{},\n            } as WorkflowNodeDataWithIndex,\n          }\n        } else if (isEdgeGroupNodeType(baseType)) {\n          newNode = createEdgeGroupNode(baseType, centerPosition)\n        } else {\n          const executorId = nanoid()\n          const preset = presetKey ? MAGENTIC_AGENT_PRESETS.find((item) => item.key === presetKey) : undefined\n          const executor = createExecutorFromNodeType(baseType, executorId, preset?.label || `New ${baseType}`, {\n            presetKey,\n          })\n          const nodeData = createNodeDataFromExecutorType(baseType as ExecutorType, executor)\n\n          newNode = {\n            id: executorId,\n            type: baseType,\n            position: centerPosition,\n            data: { ...nodeData, ...{} } as WorkflowNodeDataWithIndex,\n          }\n        }\n\n        const newNodes = [...nds, newNode]\n        saveToHistory(newNodes, edges)\n        return newNodes\n      })\n    },\n    [reactFlow, setNodes, edges, saveToHistory],\n  )\n\n  const handleAddMagenticScaffold = useCallback(() => {\n    if (!flowWrapperRef.current) {\n      return\n    }\n\n    const bounds = flowWrapperRef.current.getBoundingClientRect()\n    const centerPosition = reactFlow.screenToFlowPosition({\n      x: bounds.left + bounds.width / 2,\n      y: bounds.top + bounds.height / 2,\n    })\n\n    const currentNodes = reactFlow.getNodes() as ReactFlowNode<WorkflowNodeDataWithIndex>[]\n    const currentEdges = reactFlow.getEdges()\n\n    const findPresetKey = (node: ReactFlowNode<WorkflowNodeDataWithIndex>) => {\n      const executor = (node.data as any)?.executor as BaseExecutor | undefined\n      const metadata = (executor?.metadata as any)?.magentic\n      return metadata?.presetKey ?? metadata?.preset ?? undefined\n    }\n\n    let orchestratorNode = currentNodes.find((node) => node.type === \"magentic-orchestrator-executor\")\n    if (!orchestratorNode) {\n      const orchestratorId = nanoid()\n      const orchestratorExecutor = createExecutorFromNodeType(\n        \"magentic-orchestrator-executor\",\n        orchestratorId,\n        \"Magentic Orchestrator\",\n      )\n      orchestratorNode = {\n        id: orchestratorId,\n        type: \"magentic-orchestrator-executor\",\n        position: centerPosition,\n        data: {\n          ...createNodeDataFromExecutorType(\"magentic-orchestrator-executor\", orchestratorExecutor),\n        } as WorkflowNodeDataWithIndex,\n      }\n    }\n\n    const orchestratorId = orchestratorNode.id\n    const origin = orchestratorNode.position ?? centerPosition\n\n    const radius = 280\n    const presets = MAGENTIC_AGENT_PRESETS\n    const angleStep = presets.length ? (Math.PI * 2) / presets.length : 0\n    const nextNodesMap = new Map<string, ReactFlowNode<WorkflowNodeDataWithIndex>>()\n    currentNodes.forEach((node) => nextNodesMap.set(node.id, { ...node }))\n    nextNodesMap.set(orchestratorNode.id, { ...orchestratorNode, position: origin })\n\n    const agentNodes: ReactFlowNode<WorkflowNodeDataWithIndex>[] = presets.map((preset, index) => {\n      const angle = angleStep * index\n      const targetPosition = {\n        x: origin.x + radius * Math.cos(angle),\n        y: origin.y + radius * Math.sin(angle),\n      }\n\n      const existing = [...nextNodesMap.values()].find(\n        (node) => node.type === \"magentic-agent-executor\" && findPresetKey(node) === preset.key,\n      )\n\n      if (existing) {\n        const executor = (existing.data as any)?.executor as BaseExecutor | undefined\n        const updatedExecutor = executor\n          ? {\n              ...executor,\n              metadata: {\n                ...(executor.metadata || {}),\n                magentic: {\n                  presetKey: preset.key,\n                  capabilities: preset.capabilities,\n                },\n                source: \"agent-framework\",\n              },\n              capabilities: preset.capabilities,\n              systemPrompt: preset.systemPrompt,\n              label: preset.label,\n              description: preset.description,\n              tools: preset.toolIds?.map((toolId) => ({ toolId, enabled: true })),\n            }\n          : undefined\n\n        const updatedNode = {\n          ...existing,\n          position: targetPosition,\n          data: {\n            ...(existing.data as WorkflowNodeDataWithIndex),\n            executor: updatedExecutor ?? (existing.data as any).executor,\n            label: preset.label,\n            description: preset.description,\n          },\n        } as ReactFlowNode<WorkflowNodeDataWithIndex>\n        nextNodesMap.set(updatedNode.id, updatedNode)\n        return updatedNode\n      }\n\n      const agentId = nanoid()\n      const agentExecutor = createExecutorFromNodeType(\"magentic-agent-executor\", agentId, preset.label, {\n        presetKey: preset.key,\n      })\n\n      const newNode: ReactFlowNode<WorkflowNodeDataWithIndex> = {\n        id: agentId,\n        type: \"magentic-agent-executor\",\n        position: targetPosition,\n        data: {\n          ...createNodeDataFromExecutorType(\"magentic-agent-executor\", agentExecutor),\n        } as WorkflowNodeDataWithIndex,\n      }\n\n      nextNodesMap.set(agentId, newNode)\n      return newNode\n    })\n\n    const nextEdges = [...currentEdges]\n    const ensureEdge = (source: string, target: string) => {\n      if (!nextEdges.some((edge) => edge.source === source && edge.target === target)) {\n        nextEdges.push({ id: nanoid(), source, target, type: \"animated\" })\n      }\n    }\n\n    agentNodes.forEach((agentNode) => {\n      ensureEdge(orchestratorId, agentNode.id)\n      ensureEdge(agentNode.id, orchestratorId)\n    })\n\n    setNodes(Array.from(nextNodesMap.values()))\n    setEdges(nextEdges)\n  }, [MAGENTIC_AGENT_PRESETS, reactFlow, setEdges, setNodes])\n\n  // Handle node update from properties panel\n  const handleNodeUpdate = useCallback(\n    (nodeId: string, updates: Partial<BaseExecutor>) => {\n      let updatedNode: ReactFlowNode<WorkflowNodeDataWithIndex> | null = null\n\n      setNodes((nds) =>\n        nds.map((node) => {\n          if (node.id === nodeId && isExecutorNode(node as ReactFlowNode<WorkflowNodeDataWithIndex>)) {\n            const currentData = node.data as any\n            if (currentData.executor) {\n              const updatedExecutor = { ...currentData.executor, ...updates }\n              const nextNode: ReactFlowNode<WorkflowNodeDataWithIndex> = {\n                ...node,\n                data: {\n                  ...currentData,\n                  executor: updatedExecutor,\n                  label: updates.label ?? currentData.label,\n                  description: updates.description ?? currentData.description,\n                },\n              }\n              updatedNode = nextNode\n              return nextNode\n            }\n          }\n          return node\n        }),\n      )\n\n      if (selectedNode?.id === nodeId) {\n        setSelectedNode(updatedNode ?? null)\n      }\n    },\n    [setNodes, selectedNode],\n  )\n\n  // Check if node is an executor node\n  const isExecutorNode = (node: ReactFlowNode<WorkflowNodeDataWithIndex>): boolean => {\n    const data = node.data as any\n    return (\n      data?.variant === \"executor\" ||\n      data?.variant === \"function-executor\" ||\n      data?.variant === \"agent-executor\" ||\n      data?.variant === \"workflow-executor\" ||\n      data?.variant === \"request-info-executor\"\n    )\n  }\n\n  // Handle node selection\n  const handleNodeClick = useCallback((_event: React.MouseEvent, node: any) => {\n    setSelectedNode(node as ReactFlowNode<WorkflowNodeDataWithIndex>)\n  }, [])\n\n  // Handle workflow import\n  const handleImport = useCallback(\n    (importedNodes: any[], importedEdges: Edge[]) => {\n      setNodes(importedNodes as any)\n      setEdges(importedEdges)\n      reactFlow.fitView()\n    },\n    [setNodes, setEdges, reactFlow],\n  )\n\n  const handleEvaluate = useCallback(() => {\n    // TODO: Implement evaluate functionality\n    console.log(\"Evaluate workflow\")\n  }, [])\n\n  const handleCode = useCallback(() => {\n    // TODO: Implement code view functionality\n    console.log(\"Show code\")\n  }, [])\n\n  const handlePreview = useCallback(() => {\n    // TODO: Implement preview functionality\n    console.log(\"Preview workflow\")\n  }, [])\n\n  const handlePublish = useCallback(() => {\n    // TODO: Implement publish functionality\n    console.log(\"Publish workflow\")\n  }, [])\n\n  const handleNodeDragStart = useCallback((_event: React.MouseEvent, node: ReactFlowNode) => {\n    setDraggedNodeId(node.id)\n  }, [])\n\n  const handleNodeDragStop = useCallback(\n    (_event: React.MouseEvent, node: ReactFlowNode) => {\n      if (!draggedNodeId) return\n\n      // Find if the dragged node overlaps with any other node\n      const draggedNode = nodes.find((n) => n.id === draggedNodeId)\n      if (!draggedNode) {\n        setDraggedNodeId(null)\n        return\n      }\n\n      // Check for overlapping nodes (excluding the dragged node itself)\n      const overlappingNode = nodes.find((n) => {\n        if (n.id === draggedNodeId) return false\n\n        // Calculate node bounds (assuming standard node dimensions)\n        const nodeWidth = 300\n        const nodeHeight = 200\n\n        const draggedBounds = {\n          left: draggedNode.position.x,\n          right: draggedNode.position.x + nodeWidth,\n          top: draggedNode.position.y,\n          bottom: draggedNode.position.y + nodeHeight,\n        }\n\n        const targetBounds = {\n          left: n.position.x,\n          right: n.position.x + nodeWidth,\n          top: n.position.y,\n          bottom: n.position.y + nodeHeight,\n        }\n\n        // Check for overlap\n        return !(\n          draggedBounds.right < targetBounds.left ||\n          draggedBounds.left > targetBounds.right ||\n          draggedBounds.bottom < targetBounds.top ||\n          draggedBounds.top > targetBounds.bottom\n        )\n      })\n\n      if (overlappingNode) {\n        // Reposition the dragged node near the overlapping node\n        const offset = 350 // Distance to place the node\n        const angle = Math.atan2(\n          draggedNode.position.y - overlappingNode.position.y,\n          draggedNode.position.x - overlappingNode.position.x,\n        )\n\n        const newPosition = {\n          x: overlappingNode.position.x + Math.cos(angle) * offset,\n          y: overlappingNode.position.y + Math.sin(angle) * offset,\n        }\n\n        setNodes((nds) => {\n          const updatedNodes = nds.map((n) => (n.id === draggedNodeId ? { ...n, position: newPosition } : n))\n          saveToHistory(updatedNodes, edges)\n          return updatedNodes\n        })\n      } else {\n        // Save position change to history even if no overlap\n        saveToHistory(nodes, edges)\n      }\n\n      setDraggedNodeId(null)\n    },\n    [draggedNodeId, nodes, edges, setNodes, saveToHistory],\n  )\n\n  return (\n    <div className=\"relative h-full w-full\">\n      <TopNavigation\n        projectName={currentWorkflow.name || \"MCP Draft\"}\n        projectStatus={currentWorkflow.metadata?.custom?.status as string | undefined}\n        workflow={currentWorkflow}\n        onEvaluate={handleEvaluate}\n        onCode={handleCode}\n        onPreview={handlePreview}\n        onPublish={handlePublish}\n        onValidate={() => {\n          // TODO: Implement validation view/panel\n          console.log(\"Validate workflow\")\n        }}\n      />\n      <div ref={flowWrapperRef} className=\"absolute inset-0 w-full h-full overflow-hidden\">\n        <Canvas\n          className=\"h-full w-full\"\n          connectionLineComponent={ConnectionLine}\n          edges={edges}\n          fitView\n          nodes={nodes}\n          nodeTypes={nodeTypes}\n          onConnect={handleConnect}\n          onDragOver={handleDragOver}\n          onDrop={handleDrop}\n          onEdgesChange={onEdgesChange}\n          onNodesChange={handleNodesChangeWrapper}\n          onNodeClick={handleNodeClick}\n          onPaneClick={() => {\n            setSelectedNode(null)\n            setEdgeDropdownState(null)\n          }}\n          panOnDrag={[1]}\n          nodesDraggable={!locked}\n          selectionOnDrag={false}\n          edgeTypes={createEdgeTypes(handleEdgeHover)}\n          onNodeDragStart={handleNodeDragStart}\n          onNodeDragStop={handleNodeDragStop}\n        >\n          <NodeLibrary\n            onAddNode={handleAddNode}\n            onDragStart={handleDragStart}\n            onAddMagenticScaffold={handleAddMagenticScaffold}\n          />\n          {edgeDropdownState && (\n            <EdgeNodeDropdown\n              edgeId={edgeDropdownState.edgeId}\n              position={edgeDropdownState.position}\n              screenPosition={edgeDropdownState.screenPosition}\n              onSelectNode={handleInsertNodeOnEdge}\n              onClose={() => setEdgeDropdownState(null)}\n            />\n          )}\n          {selectedNode && (\n            <PropertiesPanel\n              selectedNode={{\n                id: selectedNode.id,\n                type: selectedNode.type || \"executor\",\n                data: selectedNode.data as any,\n              }}\n            onUpdate={(nodeId, updates) => {\n              if (locked) return\n              handleNodeUpdate(nodeId, updates)\n            }}\n            onDelete={(nodeId) => {\n              if (locked) return\n              setNodes((nds) => {\n                const newNodes = nds.filter((n) => n.id !== nodeId)\n                saveToHistory(newNodes, edges)\n                return newNodes\n              })\n              if (selectedNode?.id === nodeId) {\n                setSelectedNode(null)\n              }\n            }}\n            onDuplicate={(nodeId) => {\n              if (locked) return\n              const nodeToDuplicate = nodes.find((n) => n.id === nodeId)\n              if (nodeToDuplicate) {\n                const newId = nanoid()\n                const duplicatedNode = {\n                  ...nodeToDuplicate,\n                  id: newId,\n                  position: {\n                    x: nodeToDuplicate.position.x + 50,\n                    y: nodeToDuplicate.position.y + 50,\n                  },\n                }\n                setNodes((nds) => {\n                  const newNodes = [...nds, duplicatedNode]\n                  saveToHistory(newNodes, edges)\n                  return newNodes\n                })\n              }\n            }}\n              onEvaluate={(nodeId) => {\n                // TODO: Implement node evaluation\n                console.log(\"Evaluate node\", nodeId)\n              }}\n            />\n          )}\n          <BottomControls\n            onUndo={() => {\n              if (canUndo) {\n                const newIndex = historyIndex - 1\n                setHistoryIndex(newIndex)\n                const state = history[newIndex]\n                setNodes(state.nodes as any)\n                setEdges(state.edges)\n              }\n            }}\n            onRedo={() => {\n              if (canRedo) {\n                const newIndex = historyIndex + 1\n                setHistoryIndex(newIndex)\n                const state = history[newIndex]\n                setNodes(state.nodes as any)\n                setEdges(state.edges)\n              }\n            }}\n            canUndo={canUndo}\n            canRedo={canRedo}\n            onFitView={() => {\n              try {\n                reactFlow.fitView()\n              } catch {}\n            }}\n            locked={locked}\n            onToggleLock={() => setLocked((v) => !v)}\n          />\n        </Canvas>\n        <ExportDialog open={exportDialogOpen} onOpenChange={setExportDialogOpen} workflow={currentWorkflow} />\n        <ImportDialog open={importDialogOpen} onOpenChange={setImportDialogOpen} onImport={handleImport} />\n      </div>\n    </div>\n  )\n}\n\nclass ErrorBoundary extends React.Component<{ children: React.ReactNode }, { hasError: boolean }> {\n  constructor(props: { children: React.ReactNode }) {\n    super(props)\n    this.state = { hasError: false }\n  }\n\n  static getDerivedStateFromError() {\n    return { hasError: true }\n  }\n\n  componentDidCatch() {}\n\n  render() {\n    if (this.state.hasError) {\n      return <div className=\"p-4 text-sm\">Something went wrong.</div>\n    }\n    return this.props.children\n  }\n}\n\nconst Page = () => (\n  <ReactFlowProvider>\n    <div className=\"h-screen w-screen\">\n      <ErrorBoundary>\n        <WorkflowCanvas />\n      </ErrorBoundary>\n    </div>\n  </ReactFlowProvider>\n)\n\nexport default Page\n"],"names":[],"mappings":"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","debugId":null}}]
}